<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
		<title>TweenX - tween library for haxe</title>
		<link rel="stylesheet" href="css/main.min.css" 		type="text/css" />
		<link rel="stylesheet" href="css/prettyPhoto.css" 	type="text/css" />
		<link rel="stylesheet" href="css/shCore.css" 		type="text/css" />
		<link rel="stylesheet" href="css/shThemeDefault.css" 		type="text/css" />
		
		<script src="js/jquery-1.6.1.min.js" type="text/javascript"></script>
		<!--script src="js/jquery.lint.js" type="text/javascript" charset="utf-8"></script-->
		<script src="js/jquery.prettyPhoto.js" type="text/javascript" charset="utf-8"></script>
		<script src="js/sh/shCore.js"></script>
		<script src="js/sh/shBrushTweenX.js"></script>
		<script src="js/sh/shBrushBash.js"></script>
		<script type="text/javascript">SyntaxHighlighter.all();</script>
	</head>
	<body>
		<div id="main">
			<h1>TweenX</h1>
			<div class="content">
				[<a href=".">日本語</a>|<a href="en.html">English</a>]
				<div class="sentence">
					<p>
						TweenXは<strong>クロスプラットフォーム</strong>で動作する、Haxe向けのトゥイーンライブラリです。Haxe2、Haxe3のどちらからも利用可能で、かつ、Flash、JavaScript、C++、Neko(32bit)ターゲットで動作します。つまり、TweenXはブラウザ上でも、Windows、Mac、Linuxネイティブのソフトウェアでも、iOS、Androidのようなスマートフォンのアプリでも利用可能です。
					</p>
					<a href="sample/TweenXDemoHaxe3.swf?width=720&amp;height=512" rel="prettyPhoto" title="Flash">[Flash版デモ]</a><br />
					<a href="sample/TweenXDemoHaxe3">[HTML5版デモ]</a>
					
					
				</div>
				<h2>機能</h2>
				<div class="sentence">
					<p>
						TweenXの特徴はクロスプラットフォームだけではありません。トゥイーンをより便利する多くの機能を備えています。
					</p>
					<ul>
						<li>メソッドチェーンによるパラメータの指定</li>
						<li>41種類のイージング</li>
						<li>開始の遅延(delay)</li>
						<li>イベントハンドラの指定</li>
						<li>繰り返し、ヨーヨー、ジグザグトゥイーン</li>
						<li>一時停止、逆再生、スロー再生、早送り、ジャンプ</li>
						<li>関数トゥイーン</li>
						<li>相対値トゥイーン</li>
						<li>手動アップデートモード</li>
						<li>トゥイーンのグループ化(直列化、並列化、時間差再生)</li>
						<li>デフォルト値の変更</li>
						<li>RGB、HSVカラートゥイーン</li>
						<li>パラパラアニメーション</li>
						<li>振動エフェクト</li>
						<li>デバッグモード(-D tweenx_debug)</li>
					</ul>
					<p>
						TweenXはFlashプラットフォームと、それと類似するAPIをもつフレームワーク(NME、OpenFL、CreateJSなど)に最適化して設計されており、動作確認もNMEとOpenFLを使用して行っています。ですが、それ以外の環境であっても基本的な機能は利用可能です。
					</p>
				</div>
				<h2>速度</h2>
				<div class="sentence">
					<p>
						Flashプラットフォーム上で、15000個のオブジェクトを同時にトゥイーンさせた場合のFPSを測定しました。
					</p>
					<img src="images/benchmark.png" width="571" height="373" style="margin:10px 40px;"/>
					<p>
						この測定では、Tweenerの600倍、Actuateの1.9倍、Tween24の1.7倍、Tweensyの1.2倍程度の速度が記録されました。BetweenAS3にはやや劣るものの、数多くあるトゥイーンライブラリの中ではかなり高速な部類です。
						<br /><br />
						<a href="sample/bench/TweenXBench.swf?width=401&amp;height=401" rel="prettyPhoto" title="TweenX">[TweenX]</a>
						<br /><br />
						<!--<a href="sample/bench/TweenerBench.swf?width=401&amp;height=401" rel="prettyPhoto" title="Tweener">[Tweener]</a>-->
						<a href="sample/bench/ActuateBench.swf?width=401&amp;height=401" rel="prettyPhoto" title="Actuate">[Actuate]</a><br />
						<a href="sample/bench/Tween24Bench.swf?width=401&amp;height=401" rel="prettyPhoto" title="Tween24">[Tween24]</a><br />
						<a href="sample/bench/TweensyBench.swf?width=401&amp;height=401" rel="prettyPhoto" title="Tweensy">[Tweensy]</a><br />
						<a href="sample/bench/BetweenAS3Bench.swf?width=401&amp;height=401" rel="prettyPhoto" title="BetweenAS3">[BetweenAS3]</a><br />
						<br />
						<a href="https://github.com/shohei909/tweenx/blob/master/sample/800_BenchMark/src?at=master">[ソース]</a><br />
					</p>
				</div>
				<h2>インストール</h2>
				<p>
					haxelibを使うことで簡単にTweenXをインストールできます。コンソール上で以下のコマンドを打つだけです。
					<pre class="brush:haxe" >
						haxelib install tweenx
					</pre>
					
					インストールしたライブラリは、コンパイル時に-lib tweenxフラグを付けることで利用可能になります。
				</p>
				<h2>ソースコード</h2>
				<ul>
					<li><a href="https://github.com/shohei909/tweenx">Github</a></li>
				</ul>
				<h2>チュートリアル</h2>
				<div class="sentence">
					<h3>通常トゥイーン</h3>
					<p>
						TweenXを使うことで、オブジェクトの移動をとても簡単に表現することができます。
					</p>
					<pre class="brush:haxe" >
						...
						import tweenx909.TweenX;

						class Main extends Sprite {
							...
							public function new() {
								...
								//squareのx座標を360に移動
								TweenX.to( square, {x:360} ); 
								...
							}
						}
					</pre>
					<a href="sample/SimplestTween.swf?width=401&amp;height=401" rel="prettyPhoto" title="通常トゥイーン">[デモを再生]</a>
					<p>
						to関数は配列を渡すことで複数のオブジェクトを同時に移動させることができます。
					</p>
					<pre class="brush:haxe" >
						//3つのsquareのx座標を360に移動
						TweenX.to( [square1, square2, square3], {x:360} ); 
					</pre>
					<a href="sample/GroupTween.swf?width=401&amp;height=401" rel="prettyPhoto" title="グループトゥイーン">[デモを再生]</a>
					<h3>メソッドチェーン</h3>
					<p>
						TweenXでは、イージング(ease)、再生時間(time)、遅延時間(delay)などの値をメソッドチェーンよって指定することができます。
					</p>
					<pre class="brush:haxe" >
						...
						import tweenx909.TweenX;
						import tweenx909.EaseX;
						
						class Main extends Sprite {
							...
							public function new() {
								...
								//0.5秒後に、1.2秒かけて、指数的に減速するイージングで、squareのx座標を360に移動
								TweenX.to( square, {x:360} ).delay( 0.5 ).time( 1.2 ).ease( EaseX.expoInOut );
								...
							}
						}
					</pre>
					<p>
						トゥイーンライブラリの特徴は、イージングを指定することで簡単にオブジェクトの速度変化を指定することが出来ることです。TweenXで用意している41種類のイージングは以下のサンプルで確認できます。
					</p>
					<a href="sample/Easing.swf?width=750&amp;height=520" rel="prettyPhoto" >[イージングのサンプル]</a>
					
					<h4>using tweenx909.ChainX</h4>
					<p>
						トゥイーンの設定をメソッドチェーンで指定できることのメリットは、なんといっても<strong>強力な入力補完</strong>を受けられるということです。TweenXでメソッドチェーンが使えるのは時間やイージングの指定だけではありません。using tweenx909.ChainX;を宣言することで、トゥイーンの移動先をメソッドチェーンを使って指定できるようになります。
					</p>
					<pre class="brush:haxe" >
						...
						import tweenx909.TweenX;
						import tweenx909.EaseX;
						
						using tweenx909.ChainX;	//トゥイーンの行き先をメソッドチェーンで指定できるようにする。
						
						class Main extends Sprite {
							...
							public function new() {
								...
								TweenX.to( square ).x( 360 ).rotation( 360 ).scaleXY( 0, 0 ).delay( 0.5 ).time( 1.2 ).ease( EaseX.expoInOut );
								...
							}
						}
					</pre>
					<a href="sample/MethodChain.swf?width=401&amp;height=401" rel="prettyPhoto" title="using ChainX">[デモを再生]</a>
					<p>
						ChainXを使うことにより得られる入力補完は、Haxe3を使用している場合はより<strong>厳密</strong>で強力なものになります。例えば、Pointに対するトゥイーンでは座標(x、y)のみを変化させる関数しか補完されないのにも関わらず、Spriteに対するトゥイーンではそれらに加えて、拡大率(scaleXなど)、透明度など、その他の値に対する関数まで補完されるようになります。
					</p>
					<p>
						また、ChainXによって補完される関数はFlashターゲットや、OpenFLなどのFlashと類似するAPIを提供する環境に最適化されています。
					</p>
					<h3>直列トゥイーン(serial)</h3>
					<p>TweenX.serial()を使うことで、連続したトゥイーンを簡単に表現できます。</p>
					<pre class="brush:haxe" >
						TweenX.serial([
							TweenX.to( square1 ).x( 360 ).ease( EaseX.expoOut ),
							TweenX.to( square2 ).x( 360 ).ease( EaseX.expoOut ),
							TweenX.to( square3 ).x( 360 ).ease( EaseX.expoOut ),
						]);
					</pre>
					<a href="sample/SerialTween.swf?width=401&amp;height=401" rel="prettyPhoto" title="直列トゥイーン">[デモを再生]</a>
					<h3>並列トゥイーン(parallel)</h3>
					<p>複数のトゥイーンを同時に再生させるには、TweenX.parallel()を使います。</p>
					<pre class="brush:haxe" >
						TweenX.parallel([
							TweenX.to( square1 ).x( 360 ).ease( EaseX.expoOut ),
							TweenX.to( square2 ).x( 360 ).ease( EaseX.expoOut ),
							TweenX.to( square3 ).x( 360 ).ease( EaseX.expoOut ),
						]);
					</pre>
					<a href="sample/ParallelTween.swf?width=401&amp;height=401" rel="prettyPhoto" title="並列トゥイーン">[デモを再生]</a>
					<h3>時間差トゥイーン(lag)</h3>
					<p>複数のトゥイーンを時間差で再生させるには、TweenX.lag()を使います。</p>
					<pre class="brush:haxe" >
						TweenX.lag([
							TweenX.to( square1 ).x( 360 ).ease( EaseX.expoOut ),
							TweenX.to( square2 ).x( 360 ).ease( EaseX.expoOut ),
							TweenX.to( square3 ).x( 360 ).ease( EaseX.expoOut ),
						], 0.1 );
					</pre>
					<a href="sample/LagTween.swf?width=401&amp;height=401" rel="prettyPhoto" title="時間差トゥイーン">[デモを再生]</a>
					<h3>タイミング調節(waitとskip)</h3>
					<p>グループ化の際にタイミング調節を行いたい場合は、TweenX.wait()とskip()を使います。</p>
					<pre class="brush:haxe" >
						TweenX.serial([
							TweenX.to( square1 ).x( 360 ).ease( EaseX.expoOut ),
							TweenX.to( square2 ).x( 360 ).ease( EaseX.expoOut ),
							TweenX.wait( 0.3 ), //0.3秒待機
							TweenX.to( square3 ).x( 360 ).ease( EaseX.expoOut ).skip(), //このトゥイーンを待たずに次のトゥイーンを開始。
							TweenX.to( square4 ).x( 360 ).ease( EaseX.expoOut ),
						] );
					</pre>
					<a href="sample/WaitAndSkip.swf?width=401&amp;height=401" rel="prettyPhoto" title="waitとskip">[デモを再生]</a>
					<h3>繰り返し、ヨーヨー、ジグザグ</h3>
					<p>
						同じ動きを何度も繰り返したい場合は、repeat()を使います。さらにzigzag()、yoyo()、interval()の関数によって繰り返しを行った時の挙動を制御することが出来ます。
					</p>
					<pre class="brush:haxe" >
						TweenX.serial([
							TweenX.to( square1 ).x( 360 ).time( 0.4 ).ease( EaseX.quartOut ).repeat( 3 ), //同じ動きを3回繰り返し
							TweenX.to( square2 ).x( 360 ).time( 0.4 ).ease( EaseX.quartOut ).repeat( 5 ).yoyo(), //跳ねるようなトゥイーン
							TweenX.to( square3 ).x( 360 ).time( 0.4 ).ease( EaseX.quartOut ).repeat( 5 ).zigzag(), //往復するようなトゥイーン
						]).repeat().interval( 0.4 ); //0.4秒の間隔をあけて、無限リピート。
					</pre>
					<a href="sample/RepeatTween.swf?width=401&amp;height=401" rel="prettyPhoto" title="繰り返し、ヨーヨー、ジグザグ">[デモを再生]</a>
					<h3>デフォルト値</h3>
					<p>
						timeやeaseなどの各設定にはそれぞれのデフォルト値が用意されています。これらは、TweenX.dumpDefaults()で好きなタイミングでデフォルト値を取り出して保存したり、TweenX.setDefaults()でデフォルト値の差し戻しを行ったりが簡単に出来ます。取り出したデフォルト値は、メソッドチェーンで値を変更したり、serial、parallel、lag関数に引数として渡してグループ内のみでのデフォルト値を指定したりできます。
					</p>
					<pre class="brush:haxe" >
						//各動作設定のデフォルト値は以下のとおり
						TweenX.defaultTime		= 0.3;
						TweenX.defaultEase		= EaseX.linear;
						TweenX.defaultDelay 	= 0;
						TweenX.defaultRepeat 	= 1;
						TweenX.defaultYoyo 		= false;
						TweenX.defaultZigZag 	= false;
						TweenX.defaultInterval 	= 0; //各繰り返しの間隔。
						TweenX.defaultAutoPlay 	= true; //トゥイーンの自動開始
						
						//現在のデフォルトを取得
						var defaults:DefaultsX = TweenX.dumpDefaults();
						
						//取得した値の内容を変更する
						defaults.ease( EaseX.bounceOut ).time( 1 );
						
						//デフォルトを変更
						TweenX.setDefaults( defaults );
						
						//デフォルト値を初期状態に戻す。
						TweenX.initDefaults();
						
						//直列化したグループにデフォルト値を適用する。
						TweenX.serial([
							TweenX.to( square ).x( 360 ),
							TweenX.to( square ).alpha( 0 ),
						], defaults );
					</pre>
					<a href="sample/Default.swf?width=401&amp;height=401" rel="prettyPhoto" title="デフォルト値">[デモを再生]</a>
					
					<h3>イベントの取得</h3>
					<p>
						TweenXでは2種類のイベントの取得方法があります。1つは手軽に関数を指定できるon～関数を使う方法です。ただし、on～で指定できるイベントハンドラは1つです。複数のイベントハンドラを指定したい場合には、addEventListenerを使用します。
					</p>
					<pre class="brush:haxe" >
						//on～の関数に、Void->Voidの関数を渡すことで各種イベントを取得出来ます。
						TweenX.to( square ).x( 360 )
							.onDelay( _delay ); 		//遅延により値を更新しなかった場合に呼び出される
							.onHead( _head );			//各リピートの頭で呼び出される
							.onUpdate( _update );		//値を更新した直後に呼び出される
							.onFoot( _foot );			//各リピートの末尾に呼び出される
							.onInterval( _interval );	//リピート間のインターバルにより値が更新しなかった場合に呼び出される
							.onRepeat( _repeat );		//インターバルが終了して次のリピートが開始される直前に呼び出される
							.onRest( _rest );			//長さ調節時間により値が更新しなかった場合に呼び出される
							.onFinish( _finish );		//トゥイーンが正常に終了した場合に呼び出される
							.onProgress( _progress );	//トゥイーンの再生が進行した時に呼び出される
							.onPlay( _play );			//再生開始時に呼び出される
							.onStop( _stop );			//停止時に呼び出される
							
							
							//複数のイベントハンドラを指定したい場合addEventListenerを使います
							//この場合にイベントハンドラとして渡す関数はTweenX->Voidです
							.addEventListener( EventX.DELAY, 	delay );
							.addEventListener( EventX.HEAD, 	head );
							.addEventListener( EventX.REPEAT, 	repeat );
							.addEventListener( EventX.FOOT, 	foot );
							.addEventListener( EventX.UPDATE, 	update );
							.addEventListener( EventX.INTERVAL, interval );
							.addEventListener( EventX.REST, 	rest );
							.addEventListener( EventX.FINISH, 	finish );
							.addEventListener( EventX.PLAY, 	play );
							.addEventListener( EventX.STOP, 	stop );
					</pre>
					
					<h3>トゥイーン制御(再生、停止、早送り、逆再生)</h3>
					<p>
						TweenXでは動画を操作するような感覚で、トゥイーンを停止させたり、途中から再生したり、早送りしたり、巻き戻ししたり、自由に操ることが出来ます。	またTweenXでは、何度の再生をしても同じ開始位置と終了位置で動作が再生されます。つまり、トゥイーンを繰り返し再生することで表示が崩れることはありません。
					</p>
					<pre class="brush:haxe" >
						//停止
						tween.stop();
						
						//再生
						tween.play();
						
						//指定した再生時間に移動
						tween.goto( 0.1 );
						
						//トゥイーンを頭から再生
						tween.goto( 0, true );
						
						//現在の再生時間を取得
						tween.currentTime;
						
						//トゥイーンを最初から最後まで再生するのにかかる時間を取得
						tween.totalTime;
						
						//再生速度を変更(早送り)
						tween.timeScale = 8;
						
						//再生速度を変更(逆再生)
						tween.timeScale = -1;
						
						//TweenX全体の再生速度を変更する
						TweenX.topLevelTimeScale = 0.5;
					</pre>
					<a href="sample/TweenControl.swf?width=401&amp;height=401" rel="prettyPhoto" title="トゥイーン制御">[デモを再生]</a>
					<h3>相対値トゥイーン</h3>
					<p>
						移動先を現在地からの相対値で指定する場合は、_～()関数を使います。また、開始位置からの相対値で指定する場合は、__～()関数を使います。
					</p>
					<pre class="brush:haxe" >
						TweenX.serial([
							//以下の3つのトゥイーンはすべて同じ挙動になります。
							
							//絶対値によるトゥイーン。
							TweenX.serial([
								TweenX.to( square ).xy( 360,   0 ),
								TweenX.to( square ).xy( 360, 360 ),
								TweenX.to( square ).xy(   0, 360 ),
								TweenX.to( square ).xy(   0,   0 ),
							]),
							TweenX.wait( 0.5 ),
							
							//現在地からの相対値によるトゥイーン
							TweenX.serial([
								TweenX.to( square )._xy( 360,   0 ),
								TweenX.to( square )._xy( 360, 360 ),
								TweenX.to( square )._xy(   0, 360 ),
								TweenX.to( square )._xy(   0,   0 ),
							]),
							TweenX.wait( 0.5 ),
							
							//開始位置からの相対値によるトゥイーン
							TweenX.serial([
								TweenX.to( square ).__xy(  360,    0 ),
								TweenX.to( square ).__xy(    0,  360 ),
								TweenX.to( square ).__xy( -360,    0 ),
								TweenX.to( square ).__xy(    0, -360 ),
							]),
						]).delay( 0.5 );
					</pre>
					<a href="sample/RelativeTween.swf?width=401&amp;height=401" rel="prettyPhoto" title="相対値トゥイーン">[デモを再生]</a>
					<h3>関数トゥイーン</h3>
					<p>
						トゥイーンをさせながら関数を実行する場合、tweenFunc1()、tweenFunc2()、tweenFunc3()、tweenFunc4()、tweenFunc()のいずれかを使用します。
					</p>
					<pre class="brush:haxe" >
						function draw( x:Float, size:Float ) {
							graphics.lineStyle(1, 0x335F73 );
							graphics.drawCircle( x, 200, size );
						}
						
						TweenX.tweenFunc2( draw, 10, 10, 300, 100 ).time( 0.5 ).ease( EaseX.quadIn );
					</pre>
					<a href="sample/TweenFunction.swf?width=401&amp;height=401" rel="prettyPhoto" title="関数トゥイーン">[デモを再生]</a>
					<p>
						1、2、3、4の数字は変化させるFloatの数に対応しています。Float以外の値をトゥイーンさせたい場合や、トゥイーンさせたい値の数が4つを超える場合にはtweenFunc()関数を使用します。
					</p>
					<h3>変則トゥイーン</h3>
					<p>
						TweenXでは、Float型の値のトゥイーンの他に、Boolean、Array、RgbX、ArgbX、HsvX、AhsvX、QuakeX、TimelineXの8つの型のトゥイーンをサポートしています。
					</p>
					<h4>色(RGB,HSV)トゥイーン</h4>
					<p>
						色のトゥイーンはRGB、ARGB、HSV、AHSVに基づくものがあります
					</p>
					<pre class="brush:haxe" >
						function draw( x:Float, y:Float, color:Int ) {
							graphics.beginFill( color );
							graphics.drawRect( x, y, 8, 40 );
						}
						
						TweenX.serial([
							TweenX.tweenFunc( draw, [0, 100, RgbX.of( 0x3373EE ) 	], [380, 100, RgbX.of( 0xEE7333 ) 	] ),
							TweenX.tweenFunc( draw, [0, 180, HsvX.of( 0x3373EE ) 	], [380, 180, HsvX.of( 0xEE7333 ) 	] ),
							TweenX.tweenFunc( draw, [0, 260, new HsvX( 0,0.7,0.9 ) 	], [380, 260, new HsvX( 2,0.7,0.9 )	] ),
						]);
					</pre>
					<a href="sample/HSVTween.swf?width=401&amp;height=401" rel="prettyPhoto" title="色トゥイーン">[デモを再生]</a>
					<p>
						RgbX、ArgbX、HsvX、AhsvX型の値を元にしたトゥイーンでは、0x(AA)RRGGBB形式の整数値(Int)が出力されます。
					</p>
					
					<h4>配列トゥイーン</h4>
					<p>
						配列をトゥイーンさせることで、要素それぞれを動かすことができます。ただし、配列はトゥイーン可能な値によって構成されていることが必要です。
					</p>
					<pre class="brush:haxe" >
						var square = new GradientSquare(  
							[ 0x2C3E50, 0xE74C3C,	0xECF0F1,	 ],
							[ 0, 		0.5,		1,			 ],
							[ 0, 		64, 		255,	 	 ] 
						);
						addChild( square );
						square.x = square.y = CELL_SIZE * 6;
						
						TweenX.to( square, 
								{
									colors:[ HsvX.of(0x08A689),		HsvX.of(0xC7D93D),		HsvX.of(0xE9F2A0) 	],
									alphas:[ 1, 				 	0, 				 		0.5, 				],
									ratios:[ 0, 				 	192, 				 	255, 				]
								}).time( 2 ).ease( EaseX.expoInOut ).onUpdate( square.update );
					</pre>
					<a href="sample/ArrayTween.swf?width=401&amp;height=401" rel="prettyPhoto" title="色トゥイーン">[デモを再生]</a>
					<h4>Boolean値のトゥイーン</h4>
					<p>
						Booleanのトゥイーンではfalseを0、trueを1とみなしてトゥイーンを行い、0以下をfalse、0を超える値をtrueとみなしてBooleanへの再変換がされて出力されます。
					</p>
					<h4>振動させる</h4>
					<p>
						QuakeX型の値でトゥイーンを行うことで振動させながら値を動かすことが出来ます。
					</p>
					<pre class="brush:haxe" >
						TweenX.from( square, { x:180, y:180 } );
						TweenX.to( square, { 
											//new QuakeX( 目的地, 振動の大きさ, 振動に使うイージング )
											x:new QuakeX( 180, 80, EaseX.linear ), 
											y:new QuakeX( 180, 80, EaseX.linear ) 	
										}).time( 2 );
					</pre>
					<a href="sample/Quake.swf?width=401&amp;height=401" rel="prettyPhoto" title="アニメーション">[デモを再生]</a>
					<h4>トゥイーンによるアニメーション</h4>
					<p>
						TimelineXをトゥイーンさせる値として設定することで、連続でない値のトゥイーンが実現できます。例えば、複数のビットマップデータを差し替えることでアニメーションを実現したい場合に使用出来ます。
					</p>
					<pre class="brush:haxe" >
						TweenX.to( bitmap, {bitmapData: new TimelineX( [walk0,walk1,walk2,walk1] )}).time( 1 ).repeat( 0 );
					</pre>
					<a href="sample/TimelineTween.swf?width=401&amp;height=401" rel="prettyPhoto" title="アニメーション">[デモを再生]</a>
					<p>
						TimelineXの第1引数は、BitmapDataに限らずあらゆる値の配列が設定できます。第2引数では各要素に割り当てる時間を指定します。
					</p>
					<h4>変則トゥイーンの自作</h4>
					<p>
						上記以外のオブジェクトに対するトゥイーンも自作することができます。まず、他の変則トゥイーン(<a href="https://github.com/shohei909/tweenx/blob/master/tweenx909/rule/QuakeX.hx?at=master">QuakeXクラス</a>など)を参考に<a href="https://github.com/shohei909/tweenx/blob/master/tweenx909/rule/RuleX.hx?at=master">RuleX</a>型の条件を満たす、自作のクラスを作成し、TweenX.addRule関数を使って新しいルールを追加します。
					</p>
					<pre class="brush:haxe" >
						TweenX.addRule( CustomRule );
					</pre>
				</div>
				<h2>発展した内容</h2>
				<div class="sentence">
					<p>
						これ以降の内容は必ずしも知っている必要は無い内容ですが、より安全に、より正確に、より便利にTweenXを使いたい場合には一読しておくと良いでしょう。
					</p>
					<h3>手動更新モード</h3>
					<p>
						updateModeをMANUALに設定してフレーム毎にmanualUpdateを呼び出しを行うことで、トゥイーンの更新のタイミングを自分で制御することができます。
					<pre class="brush:haxe" >
						...
						import tweenx909.TweenX;
						import tweenx909.advanced.UpdateModeX;
						...
						
						class Main extends Sprite {
							...
							public function new() {
								...
								TweenX.updateMode = UpdateModeX.MANUAL;
								addEventListener( "enterFrame", onFrame );
								...
							}
							
							function onFrame( e ){
								TweenX.manualUpdate( 1/60 ); //全トゥイーンを1/60秒更新。
							}
						}
					</pre>
					</p>
					
					<h3>トゥイーンの初期化</h3>
					<p>
						TweenXでは、再生中に値が変更されることによる再現性の低いバグの発生や、プログラマが意図していない挙動をなくすために、トゥイーンが初期化された後に目的位置や設定を変更することを禁止しています。
					</p>
					<p>
						トゥイーンの初期化は次のいづれかの内、最も早いタイミングで行われます。
					</p>	
					<ul>
						<li>play、goto、updateの呼び出し時</li>
						<li>トゥイーンが定義された直後のアップデート時</li>
					</ul>
					<p>
						そして、トゥイーンの初期化では以下のことが行われます。
					</p>	
					<ul>
						<li>トゥイーンの開始位置の決定</li>
						<li>目的位置と各設定値(ease,time,repeat,yoyo,zigzag,intarval,delay)の固定</li>
						<li>autoPlayがtrueに設定されたトゥイーンの開始</li>
					</ul>
					<p>	トゥイーンが初期化された後に設定や目的位置を変更しようとすれば、実行エラーが発生します。一見、設定や目的位置が変更不能なことはデメリットのようですが、一度定義したトゥイーンが不変であることは大きなメリットをもたらします。TweenXによって定義されたトゥイーンはまるで<strong>動画のように</strong>振る舞います。つまり、トゥイーンを途中から再生したり、逆再生したり、早送りしたり、時間をおいてからもう一度再生したとしても、トゥイーンが崩れることはありません。
					</p>
					<p>
						そしてトゥイーンが不変であることのもう一つのメリットが、トゥイーン開始位置の記述です。
					</p>
					<h4>開始位置</h4>
					<p>
						トゥイーンの開始位置は、基本的には初期化が行われた時のターゲットの値になります。ただし、同一のフレーム内ですでにターゲットが同じトゥイーンが定義されていた場合、そのトゥイーンの続きとして開始位置が設定されます。このため、TweenXでは同じ値を2度記述する必要はありません。もちろんトゥイーンがターゲットの再生時の状態から影響を受けることも無いので、ターゲットの移動について余計な配慮をする必要もありません。
					</p>
					<pre class="brush:haxe" >
						var defaults = TweenX.dumpDefaults();
						defaults.time( 1 ).ease( EaseX.quartOut );
						
						TweenX.serial([
							//前回のアップデートから現在までに定義されたトゥイーンが存在しないので、トゥイーンが初期化されたときの座標から開始
							TweenX.to( square ).x( 360 ).y(   0 ),
							
							//次のトゥイーンはx:360、y:0から
							TweenX.to( square ).x( 360 ).y( 360 ).yoyo().repeat( 2 ),
							
							//ヨーヨーにより戻ってくるので、次のトゥイーンはx:360、y:0から
							TweenX.to( square ).x(   0 ).y( 360 ).zigzag().repeat( 3 ),
							
							//次のトゥイーンはx:0、y:360から
							TweenX.to( square ).x(   0 ).y(   0 ),
						], defaults ).repeat();
					</pre>
					<a href="sample/AutoFrom.swf?width=401&amp;height=401" rel="prettyPhoto" title="開始位置">[デモを再生]</a>
					<p>
						この際に注意すべき点は、開始位置は前述のトゥイーン初期化時に決定するということです。トゥイーン開始位置の決定はあくまでトゥイーンを定義した順序に基づいて行われるので、以下のように再生の順序と定義の順序を逆にすると連続でないトゥイーンが生成されます。
					</p>
					<pre class="brush:haxe" >
						TweenX.to( square ).x( 180 ).delay( 2 );
						TweenX.to( square ).x( 360 ).delay( 1 );
					</pre>
					<a href="sample/BadSample.swf?width=401&amp;height=401" rel="prettyPhoto" title="良くない例">[デモを再生]</a>
					<p>
						また開始位置は、TweenX.from()関数を使って明示的に指定することもできます。
					</p>
					<h3>メモリの解放</h3>
					<p>	トゥイーンライブラリの扱う上で、どうすればメモリリークを起こさないかは非常に重要です。TweenXでメモリリークを起こさない方法は簡単です。<strong>使わなくなったトゥイーンを停止</strong>してください。stopにより停止したトゥイーンは、TweenXのライブラリ内からの参照がないため、ガーベジコレクションの対象になりえます。再生時間の短いトゥイーンであれば、再生終了と同時にstopされます。ただしrepeatを0に指定した無制限の繰り返しトゥイーンや再生時間の長いトゥイーンは、必要が無くなると同時にstopを行ってください。
					</p>
					<p>
						もうひとつ、メモリリークを起こす要因となるのがupdateModeをMANUALに設定したにも関わらずmanualUpdate呼び出しを行っていない場合です。manualUpdateでは、先述のトゥイーンの初期化が行われるので、manualUpdate呼び出しを行わないと初期化待ちのトゥイーンが大量にたまってしまいメモリリークを引き起こす場合があります。<strong>updateModeをMANUALに設定した場合、必ず定期的にmanualUpdateを呼び出してください</strong>。
					</p>
					<h3>デバッグモード</h3>
					以下のコンパイラフラグを指定することで、TweenXに関する情報が出力されます。
					<pre class="brush:bash" >
						-D tweenx_debug
					</pre>
					
					出力される内容は以下のような全トゥイーンの動作に関する情報です。
					
					<pre class="brush:bash" >
						...
						Main.hx:171: Tween_20(generated at TweenXPlayer/change()[TweenXPlayer.hx:102]) UPDATE
						Main.hx:171: Tween_21(generated at TweenXPlayer/change()[TweenXPlayer.hx:98]) UPDATE
						Main.hx:171: Tween_23(generated at TweenXPlayer/change()[TweenXPlayer.hx:105]) UPDATE
						Main.hx:171: Tween_24(generated at TweenXPlayer/change()[TweenXPlayer.hx:102]) UPDATE
						Main.hx:171: Tween_20(generated at TweenXPlayer/change()[TweenXPlayer.hx:102]) UPDATE
						Main.hx:171: Tween_20(generated at TweenXPlayer/change()[TweenXPlayer.hx:102]) FOOT
						Main.hx:171: Tween_20(generated at TweenXPlayer/change()[TweenXPlayer.hx:102]) FINISH
						Main.hx:171: Tween_20(generated at TweenXPlayer/change()[TweenXPlayer.hx:102]) STOP
						Main.hx:171: Tween_21(generated at TweenXPlayer/change()[TweenXPlayer.hx:98]) UPDATE
						Main.hx:171: Tween_21(generated at TweenXPlayer/change()[TweenXPlayer.hx:98]) FOOT
						Main.hx:171: Tween_21(generated at TweenXPlayer/change()[TweenXPlayer.hx:98]) FINISH
						...
					</pre>
					
					各トゥイーンのupdateに関する情報が要らない場合、以下のように指定します。
					<pre class="brush:bash" >
						-D tweenx_debug -D tweenx_debug_hide_update
					</pre>
					<h3>グループ化時の注意点</h3>
					<p>
						serial、parallel、lag関数は、グループ化の際に内部のトゥイーンのdelayとrestの時間を調節して、すべてのトゥイーンの長さを単一に揃えることで連続的なトゥイーンを実現します。このため、特定のトゥイーンが開始するタイミングを取得したい場合、イベントハンドラを設定するよりも、TweenX.func()関数を使うことが推奨されます。
					</p>
					<h3>グループ全体に対するイージングの設定</h3>
					<p>
						TweenXでは個別のトゥイーンのみではなく、serial、parallel、lag関数によってグループ化したトゥイーンの全体に対してもイージングを指定することができます。
					</p>
					<pre class="brush:haxe" >
						TweenX.serial([
							TweenX.to( square ).time( 0.48 ).x( 120 ),
							TweenX.to( square ).time( 0.80 ).x( 240 ).y( 260 ),
							TweenX.to( square ).time( 0.48 ).x( 360 )
						]).ease( EaseX.bounceInOut );
					</pre>
					<a href="sample/GroupEase.swf?width=401&amp;height=401" rel="prettyPhoto" title="グループのイージング">[デモを再生]</a>
					<p>
						グループのイージングは明示的に指定しないかぎりEaseX.linearです。重複してイージングが指定されてしまうことを避けるため、デフォルト値の影響は受けません。
					</p>
				</div>
			</div>
		</div>
	
		<script type="text/javascript" charset="utf-8">
		$(document).ready(function(){
			$("a[rel^='prettyPhoto']").prettyPhoto({social_tools:false, allow_expand:false});
		});
		</script>
	</body>
</html>