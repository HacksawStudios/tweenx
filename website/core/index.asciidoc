---
layout: default
title: TweenXCore - lightweight motion library for haxe
logo: +++<span class="tweenxcore">TweenX<span class="core">Core</span></span>+++
---
:showtitle:
:author: shohei909
:toc: macro
:toc-title: 目次
:toclevels: 4
:sampleLink: link:https://github.com/shohei909/tweenx/blob/develop/sample/
:sourceLink: link:https://github.com/shohei909/tweenx/blob/develop/src/tweenxcore/
:page-liquid:

= {{page.logo}}

{{page.logo}}は https://haxe.org/[Haxe] で気持ちの良いモーションをより簡単に作成するための、シンプルな**トゥイーンライブラリ**です。

実行速度を速く、開発速度を速く、バグを少なく、学習コストを少なく、そしてモーションを自由に面白くするために作られています。

{% include sample.asciidoc num="312" title="CustomEasing" %}

toc::[]


== 機能

* 44種類のイージング関数
* 繰り返し
* ヨーヨー、ジグザグ運動
* イージングのミックス、クロスフェード、連結などのカスタム機能
* HSVカラー、RGBカラー
* 極座標
*　ベジェ曲線
*　``lerp``、``inverseLerp``、``clamp``など、``Float``の機能の拡張


== 速度

余計な処理やインスタンス生成を行わないため、非常に高速に動作します。

{sampleLink}tweenx/800_BenchMark/src[[コードを見る(Github)\]]


== ライセンス

MITライセンスですので、商用、非商用、個人、法人を問わず、利用、改変、再配布ができます。


== {{page.logo}}を始める

=== Haxeバージョン

http://haxe.org/[Haxe]の3.1.3以降をサポートしています。


=== インストール

Haxeのインストール後、コマンドラインから以下のコマンドを入力してください。

[source, shell]
---------
haxelib install tweenxcore
---------

=== Hello {{page.logo}}

{{page.logo}}の最初のサンプルとして、四角のx座標を0から420まで、動かすコードを見てみます。

{% include sample.asciidoc num="301" title="Simplest" %}

[source,haxe,linenums]
---------
import flash.display.Sprite;
import flash.events.Event;
import sample.SampleSuport.Square;
using tweenxcore.Tools;

class Sample extends Sprite {
    var square:Square;
    var frameCount = 0;

    public function new() {
        super();
        addChild(square = new Square());
        square.x = 15;
        square.y = Square.SIZE * 2.5;
        
        addEventListener(Event.ENTER_FRAME, onFrame);
    }
    
    // フレームごとに呼び出し。
    function onFrame(e:Event) {
        var rate = frameCount / 20;
        if (rate <= 1) {
            square.x = rate.quadOut().lerp(15, 435);
        }
        frameCount++;
    }
}
---------

サンプルはFlashプラットフォームのコードですが、他のプラットフォームであっても{{page.logo}}の使い方はほとんど変わりません。

{{page.logo}}の説明として重要なのは以下のコードです。

[source,haxe]
---------
using tweenxcore.Tools;
---------

[source,haxe]
---------
            square.x = rate.quadOut().lerp(15, 435);
---------



それでは1つづつ要素を見ていきます。


==== using tweenxcore.Tools

ここで読み込んでいる``tweenxcore.Tools``モジュールは4種類のクラスを持っています。

Easingクラス::
  モーションの曲線として使われる、イージング関数を持ちます

FloatToolsクラス::
  Floatの機能を拡張します。

PointToolsクラス::
  XY座標上の点の拡張です。ベジェ曲線の機能を付け加えます。Flashの``Point``クラスに対してだけではなく、様々なライブラリの``Point``型に対して使えます。

MatrixToolsクラス::
  XY座標のアフィン変換の行列の拡張です。2次元的な動きを相似変換するための機能を付け加えます。Flashの``Matrix``クラスに対してだけではなく、{sourceLink}tweenxcore/geom/Matrix.hx[似たインターフェース]を持つその他のライブラリの``Matrix``型に対して使えます。

``using tweenxcore.Tools;``でこのすべてを拡張として読みこみます。

チュートリアルで紹介する関数の多くはこの``Tools``のモジュールにありますから、そのソースを参照しながら読み進めると理解がしやすいかと思います。

{sourceLink}tweenxcore/Tools.hx[[ソースを見る(tweenxcore.Tools)\]]


==== イージング関数

``quadOut``はイージング関数です。0から1へと変化する``rate``の値を、2次関数をつかって後詰めの値へと変えています

{{page.logo}}が提供するイージング関数はもちろん``quadOut``のみではありません。

link:http://easings.net/[Robert Pennerのイージング関数]を基本とし、中央で減速して再度加速する``OutIn``のモードと、瞬間的に移動を行うwarpが追加された計44個の関数を提供しています。

{% include sample.asciidoc num="400" title="EasingVisualizer" width=700 height=500 %}


{{page.logo}}での、``cubicIn``関数は以下の通りです。

[source,haxe]
---------
function cubicIn(t:Float):Float {
    return t * t * t;
}
---------

ただ単にFloatを受け取ってFloatを返す、とてもシンプルな関数です。


この関数を使って先ほどのサンプルコードにのイージングをつけてみます。たった1行、以下のように変更を加えます。

[source,haxe]
---------
square.x = part.current.cubicIn().lerp(15, 435);
---------

``part.current``の0.0から1.0までの値を、``cubicIn()``を使ってカーブをつけた後に、``lerp``関数で15から435の値に変換しています。{{page.logo}}を使用するコードでは、このようなFloatの値に対するメソッドチェーンがよく出てきます。

{% include sample.asciidoc num="302" title="Easing" %}


==== lerp

``lerp`` は線形補間の関数で、``tweenxcore.Tools.FloatTools``が持つ関数です。0.0から1.0の値を指定した範囲の値、例の場合、15から435までの値に変換しています。これにより、``rate``が0.0から1.0まで変化する間に、``square.x``は15から435へと移動します。



== {{page.logo}}の思想

=== 脱ブラックボックス

{{page.logo}}は、出発地点や到達地点を指定して自動


例えば

* **「一時停止ボタンが押されたときにゲーム内のアニメーションをすべて一時停止した上で、さらにアニメーション付きでポップアップを表示させたい」**ことがあります。
* 通信待ちのインジケータなら、**「インジケータのフェードイン中に通信が終われば、フェードインの途中からフェードアウトに切り替えをしたい」**と思うはずです。


=== 0.0から始まり、1.0で終わる

{{page.logo}}の世界では、始まりの値は0.0であり、終わりの値は1.0です。つまり、

* モーションの時刻の場合、開始時刻は0.0で表し終了時刻は1.0を使います。
* アルファ値の場合、完全な透明は0.0で完全な不透明は1.0です。
* 円の1周の場合、0度は0.0であり360度は1.0です。
* RGBカラーのRed値の場合、0.0が赤みが全くなく1.0が完全な赤です。

{{page.logo}}では、このような0.0から1.0を基準とする値について``rate``という変数名をよく使います。



== {{page.logo}}チュートリアル


=== イージングを自作する

{{page.logo}}には44種類のイージングありますがこれらを単に使うだけでは、ありふれたモーションになりがちです。{{page.logo}}ではイージングを組み合わせたり混ぜ合わせたりして自分だけのイージングを作り出すことができます。


==== ヨーヨー

ヨーヨーは0.0から1.0に行って、逆再生の動きで0.0に帰ってくるようなモーションです。

{% include sample.asciidoc num="304" title="Yoyo" %}

```haxe
// ヨーヨー
square.x = rate.yoyo(Easing.quintOut).lerp(15, 435);
```

==== ジグザグ

ジグザグは0.0から1.0に行って、移動方向を反転させた動きで0.0に帰ってくるようなモーションです。

{% include sample.asciidoc num="319" title="Zigzag" %}

```
// ジグザグ
square.x = rate.zigzag(Easing.quintOut).lerp(15, 435);
```

==== 多重のイージング（関数合成）

イージングを2重、3重に使うと、新しい動きを作ることができます。

{% include sample.asciidoc num="307" title="Composite" %}

```haxe
// 上
square1.x = rate.quintInOut().quintInOut().lerp(15, 435);

// 下
square2.x = rate.cubicIn().bounceOut().lerp(15, 435);
```

上は``quintInOut``を2重に使ってより急激な加速減速を作っており、下は``cubicIn``と``bounceOut``で加速していくバウンドのイージングを作っています。


==== ミックス

``mixEasing``は2つのイージングの中間的なイージングです。

{% include sample.asciidoc num="308" title="Mix" %}

```haxe
square.x = rate.mixEasing(Easing.expoOutIn, Easing.linear, 0.12).lerp(15, 435);
```

サンプルとしてゲームのカットイン演出にありそうなイージングを作りました。``expoOutIn``に``linear``関数を``0.12``ミックスすることで、``OutIn``のイージングの真ん中でピタッっと止まる感じを無くしています。


==== クロスフェード

``crossfadeEasing``は、始まりと終わりで別のイージングに徐々に変わっていくようなイージングです。

{% include sample.asciidoc num="309" title="Crossfade" %}

```haxe
square.x = rate.crossfadeEasing(
    Easing.quintOut,
    Easing.bounceOut,
    Easing.sineInOut
).lerp(15, 435);
```

サンプルは``quintOut``として始まって、徐々に``Easing.bounceOut``に変わっていくイージングです。変化の仕方の曲線として``Easing.sineInOut``を使っています。


==== コネクト

``connectEasing``は、2つのイージングをつなげて再生する機能です。

{% include sample.asciidoc num="310" title="Connect" %}

```haxe
square.x = rate.connectEasing(Easing.backOut, 0.9, 0.4, Easing.linear).lerp(15, 435);
```

サンプルでは、最初の``0.9``の時間で``0.4``の位置まで``backOut``で移動した後、残りを``linear``で移動しています。


==== ワンツー

``oneTwoEasing``は、別々のイージングで2回移動を行うイージングです。

{% include sample.asciidoc num="311" title="OneTwo" %}

```haxe
square1.x = rate.oneTwoEasing(Easing.backIn, 0.8, Easing.linear).lerp(45, 405);
```

単純に``backIn``で1回目の``linear``で2回目の移動を行っています。


==== CustomEasingクラス

このようなイージングのカスタム機能を何度も使う場合、自作のイージングをまとめたCustomEasingクラスを作っておくと便利です。

```haxe
using tweenxcore.Tools;

class CustomEasing {
    public static inline function quintQuintInOut(rate:Float) {
       return rate.quintInOut().quintInOut();
    }
}
```

このように``CustomEasing``クラスを定義しておけば、自分の作ったイージングを``using packageName.CustomEasing;``して簡単に利用できるようになります。


==== イージングエディタ

イージングエディタは、イージングを自作するためのツールです。イージングを組み合わせをブラウザ上で実際に試しながら作ることができます。

image::/images/easing_editor_ja.png[alt="イージングエディタ" class="large" link="./custom/"]
link:./custom/[イージングエディタ | TweenXCore]


=== 変化量をあつかう（FloatChange）



==== 繰り返し

1つのパートを、複数回繰り返したい場合、``handlePart``の代わりに``handleRepeatPart``を使います。

{% include sample.asciidoc num="303" title="Repeat" %}

[source,haxe]
---------
change.handleRepeatPart(5, 25, 3, updateSquare);
---------

このサンプルでは、5フレーム目から65フレーム目までの60フレームの間に``FloatChangePart``の0.0から1.0の移動が3回繰り返されています。

``handleRepeatPart``が``updateSquare``に引数として渡す``FloatChangePart``は``FloatChangeRepeatPart``として拡張したもので、現在が何回目の繰り返しかなどの追加の情報にアクセスができます。

{sourceLink}tweenxcore/structure/FloatChangeRepeatPart.hx[[ソースを見る(tweenxcore.structure.FloatChangeRepeatPart)\]]


==== モーションの特定のタイミングに処理をする

``FloatChangePart``には、モーションの開始タイミングや、終了タイミングを取得するための関数が用意されています。

{% include sample.asciidoc num="305" title="CrossOver" %}

この例では、パートの開始のタイミング、真ん中のタイミング、終了のタイミングのみ``true``になるフラグを使って各タイミングで色を変えています。

```haxe
function updateSquare(part:FloatChangePart) {
	square.x = part.current.cubicIn().lerp(15, 435);

	// パートの開始タイミングだったら、赤に変更
	if (part.isEntrance())
	{
		square.transform.colorTransform = new ColorTransform(0, 0, 0, 1, 0xFF, 0x78, 0x78);
	}

	// パートが半分経過したタイミングだったら、緑に変更
	if (part.isCrossOver(0.5))
	{
		square.transform.colorTransform = new ColorTransform(0, 0, 0, 1, 0x78, 0xFF, 0x78);
	}

	// パートの終了タイミングだったら、青に変更
	if (part.isExit())
	{
		square.transform.colorTransform = new ColorTransform(0, 0, 0, 1, 0x78, 0x78, 0xFF);
	}
}
```

====　連続したモーションをあつかう

連続したモーションをあつかうには、``FloatChange``の``handleTimelinePart``が使えます。

{% include sample.asciidoc num="306" title="TimelinePart" %}

右、下、左の三つの移動を行いました。

```haxe
var timeline:Timeline<FloatChangeTimelinePart->Void>;

public function new() {
    // (中略)

    // 重み付きのupdate関数の配列を作成。
    timeline = new Timeline().add(update1, 1).add(update2, 3).add(update3, 12);
}

function onFrame(e:Event) {
    var change = new FloatChange(frameCount, frameCount += 1);

    // Timelineに合わせて、update関数呼び出し。
    change.handleTimelinePart(0, 80, timeline);
}

function update1(change:FloatChangeTimelinePart) {
    // 右へ移動
    square.x = change.current.lerp(15, 435);
}

function update2(change:FloatChangeTimelinePart) {
    // 下へ移動
    square.y = change.current.cubicInOut().lerp(15, 135);
}

function update3(change:FloatChangeTimelinePart) {
    // 左へ移動
    square.x = change.current.quartIn().cubicIn().lerp(435, 15);
}
```

``Timeline``は重み付きの配列です。配列の各要素に``Float``で重みがつけられています。サンプルでは``update1, update2, update3``に``1:3:12``の重みを付けています。

``handleTimelinePart``は、この重みに従ってupdate関数を呼び出します。サンプルでは、5フレームかけて``update1``を、15フレームかけて``update2``を、60フレームかけて``update3``を呼び出しています。

``FloatChangeTimelinePart``は``FloatChangePart``を継承しており、現在タイムラインのどの位置にいるかなどの情報が追加で取得できます。

{sourceLink}tweenxcore/structure/FloatChangeTimelinePart.hx[[ソースを見る(tweenxcore.structure.FloatChangeTimelinePart)\]]


=== 2次元の動き

==== マトリックス

いままでのモーションはすべてX方向の動きをあつかってきましたが、Y方向の動きも入れてみます。

{% include sample.asciidoc num="313" title="Xy" %}

```haxe
square.x = rate.expoOutIn().lerp(15, 435);
square.y = rate.sinByRate().lerp(75, 95);
```

四角をY方向に揺らしてみました。ここで使っている``sinByRate``は円の一周を1.0としてあつかう``sin``関数です。

このサンプルはそれほど目新しくはありません。問題は同じようなモーションを斜め方向に行う場合です。これまで0.0から1.0の値を実際の``x``座標に変換するのには``lerp``関数を使ってきましたが、回転が加わる場合``lerp``関数は使えません。

そういった場合は、``MatrixTools.createSimilarityTransform``を使います。

{% include sample.asciidoc num="314" title="Matrix" %}

```haxe
var matrix:flash.geom.Matrix;

public function new() {
	// (中略)

	// X座標を100から350、Y座標を15から135に移動するための行列を作成
	matrix = new flash.geom.Matrix();
	matrix.createSimilarityTransform(100, 15, 350, 135);
}

function updateSquare(part:FloatChangePart) {
	var x = rate.expoOutIn();
	var y = rate.sinByRate().lerp(0, 0.1);
	var point = matrix.transformPoint(new Point(x, y));

	square.x = point.x;
	square.y = point.y;
}
```

``createSimilarityTransform(fromX, fromY, toX, toY)``は、X方向の0.0から1.0までの移動を、X方向に``fromX``から``toX``Y方向に``fromY``から``toY``の移動に相似変換するような行列を作成します。

==== 極座標

{{page.logo}}は極座標をサポートしています。

{% include sample.asciidoc num="315" title="Polar" %}

```haxe
var matrix:Matrix;

public function new() {
	// (中略)

	// 相似変換を作成
	matrix = new Matrix();
	matrix.createSimilarityTransform(225, 75, 15, 15);
}

function updateSquare(part:FloatChangePart) {
	// 原点に近づいていく
	var distance = rate.expoOut().lerp(1, 0);
	// 反時計回りに2周する。
	var angle = rate.lerp(0, -2);
	var polarPoint = new PolarPoint(distance, angle);

	// 実際の座標へ変換
	var point = matrix.transformPoint(new Point(polarPoint.x, polarPoint.y));
	square.x = point.x;
	square.y = point.y;
}
```

サンプルは、``(x, y)=(225, 75)``を極座標の中心として、そこに``(x, y)=(15, 15)``の位置から回転しながら近づいていくモーションです。

{sourceLink}tweenxcore/geom/PolarPoint.hx[[ソースを見る(tweenxcore.geom.PolarPoint)\]]


==== ベジェ曲線

{{page.logo}}はベジェ曲線もサポートしています。

{% include sample.asciidoc num="316" title="Bezier" %}

```haxe
square.x = rate.bezier3(15, 50, 400, 435);
square.y = rate.bezier3(15, 200, -50, 135);
```

サンプルは、始点が``(15, 15)``、制御点が``(50, 200)``と``(400, -50)``、終点が``(400, 135)``の3次ベジェ曲線です。

ベジェ曲線は3次だけでなく任意の次数ののベジェ曲線が使えます。詳しくは``tweenxcore.Tools``モジュールを確認してください。

{sourceLink}tweenxcore/Tools.hx[[ソースを見る(tweenxcore.Tools)\]]



=== いろんなものを動かす

==== RGBカラー、HSVカラー

{{page.logo}}では、RGBカラーとHSVカラーが使えます。

{% include sample.asciidoc num="317" title="Color" %}

```haxe
var prevX = part.previous.expoInOut().lerp(0, 450);
var currentX = part.current.expoInOut().lerp(0, 450);

// RGB
var rgbCurve = part.current.expoInOut();
var red = rgbCurve.lerp(0.8, 0.7);
var green = rgbCurve.lerp(0.7, 1);
var blue = rgbCurve.lerp(0.5, 1);
graphics.beginFill(new RgbColor(red, green, blue).toInt());
graphics.drawRect(prevX, 30, currentX - prevX, 30);

// HSV
var hsvCurve = part.current.expoInOut();
var hue = hsvCurve.lerp(0.0, 1.0);
var saturation = hsvCurve.lerp(0.0, 0.8);
var value = 0.95;
graphics.beginFill(new HsvColor(hue, saturation, value).toInt());
graphics.drawRect(prevX, 90, currentX - prevX, 30);
```

サンプルはRGBと、HSVのそれぞれの値を動かしながら帯を描いています。

{sourceLink}tweenxcore/color[[ソースを見る(tweenxcore.color)\]]



==== 画像

連続したモーションをあつかうのに重み付き配列の``Timeline``を紹介しましたが、この``Timeline``は画像のパラパラアニメーションを作るのにも使えます。

{% include sample.asciidoc num="318" title="Bitmap" width="151" %}
