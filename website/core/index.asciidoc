---
layout: default
title: TweenXCore - lightweight motion library for haxe
logo: +++<span class="tweenxcore">TweenX<span class="core">Core</span></span>+++
---
= {{page.logo}}
:showtitle:
:author: shohei909
:toc: macro
:toc-title: 目次
:toclevels: 4
:sampleLink: link:https://github.com/shohei909/tweenx/blob/develop/sample/
:sourceLink: link:https://github.com/shohei909/tweenx/blob/develop/src/tweenxcore/

{{page.logo}}は気持ちの良いモーションをより簡単に作成するためのHaxeのライブラリで、**トゥイーンライブラリの代替**となるライブラリです。

トゥイーンライブラリを使うよりも、実行速度を速く、開発速度を速く、バグを少なく、学習コストを少なく、そしてモーションを自由に面白くするために作られています。

{% include movie.asciidoc file="390" %}

toc::[]

== 機能

* 46種類のイージング関数
* 繰り返し
* ヨーヨー、ジグザグ運動
* イージングのミックス、クロスフェード、連結などのカスタム機能
* HSVカラー、RGBカラー
* 極座標
*　ベジェ曲線
*　``lerp``、``inverseLerp``、``clamp``など、``Float``の機能の拡張



=== {{page.logo}}が持たないもの

バックグラウンドでの動作::
  {{page.logo}}がバックグラウンドでオブジェクトを操作することはありません。あなた自身が今どういう状態であるべきかを記述してください。

イベントリスナー::
  {{page.logo}}では何かしらの処理を予約しておくことはできません。モーションの終了タイミングなどはif文を書くことで判別します。

ツリー構造::
  {{page.logo}}は独自のツリー構造を持ちません。

これらの機能は一見便利ですが、安易に使うとバグを生んだり設計を難しくしたりします。モーションを作るという目的に限れば、これらは不必要です。これらの要素をもたないことで、{{page.logo}}自身と、それを使用するコードはシンプルに保たれます。



== 速度

Flashプラットフォーム上で動作するトゥイーンライブラリとしておそらく最速であるBetweenAS3よりも、さらに高速に動作しています。

{sampleLink}tweenx/800_BenchMark/src[[コードを見る(Github)\]]



== {{page.logo}}の思想

=== 脱トゥイーンライブラリ

トゥイーンライブラリはバグの温床になりやすいものです。

同じオブジェクトに対して2つのトゥイーンが走ったときの挙動は混乱を生みます。常にメモリリークを気にかけながら実装を行う必要があります。イベントハンドラの取り扱いも厄介です。

トゥイーンライブラリはとりあえず動くコードを書くのに便利で、プロトタイプや小さなゲームを作るのに向いていますが、もっと大きな製品を作る場合は事情が違います。

例えば

* ゲームの場合、**「一時停止ボタンが押されたときにゲーム内のアニメーションをすべて一時停止した上で、さらにアニメーション付きでポップアップを表示させたい」**ことがあります。
* 通信待ちのインジケータなら、**「インジケータのフェードイン中に通信が終われば、フェードインの途中からフェードアウトに切り替えをしたい」**と思うはずです。

これらは、トゥイーンライブラリの苦手分野です。

もちろんTweenXはそういった用途にも耐えうるように細心の注意をはらって設計していますが、そういったものを作るには動作を詳細に知らなくてはいけませんし、コードの量も複雑度も大きくなりがちです。

わたし自身もTweenXのバックグラウンドで何かをやってくれるような機能は使わなくなり、TweenXのイージング関数を直接使ってモーションのコードを書くようになっていました。

そしてイージング関数とほんの少しの機能を用意すれれば、トゥイーンライブラリよりも自由で、簡単で、高速なライブラリができることに気が付きました。そうして作られたのが{{page.logo}}です。



=== 0.0から始まり、1.0で終わる

{{page.logo}}の世界では、始まりの値は0.0であり、終わりの値は1.0です。つまり、

* モーションの時刻の場合、開始時刻は0.0で表し終了時刻は1.0を使います。
* アルファ値の場合、完全な透明は0.0で完全な不透明は1.0です。
* 円の1周の場合、0度は0.0であり360度は1.0です。
* RGBカラーのRed値の場合、0.0が赤みが全くなく1.0が完全な赤です。

{{page.logo}}では、このような0.0から1.0を基準とする値について``rate``という変数名をよく使います。

{{page.logo}}はトゥイーンライブラリではありません。**この0.0から1.0を基準とする値を、自由にあやつるためのツール**だと考えてください。



=== オープンソース

MITライセンスですので、商用、非商用、個人、法人を問わず、利用、改変、再配布ができます。



== {{page.logo}}を始める

=== Haxeバージョン

http://haxe.org/[Haxe]の3.1.3での動作を確認しています。


=== インストール

Haxeのインストール後、コマンドラインから以下のコマンドを入力してください。

[source, shell]
---------
haxelib install tweenxcore
---------

=== Hello {{page.logo}}

{{page.logo}}の最初のサンプルとして四角のx座標を0から420まで、動かすコードを見てみます。

{% include sample.asciidoc num="301" title="Simplest" %}

[source,haxe,linenums]
---------
import openfl.display.Sprite;
import openfl.events.Event;
import sample.SampleSuport.Square;
import tweenxcore.structure.FloatChange;
import tweenxcore.structure.FloatChangePart;
using tweenxcore.Tools;

class Sample extends Sprite {
    public static inline var MOTION_END = 60;
    var square:Square;
    var frameCount = 0;

    public function new() {
        super();
        addChild(square = new Square());
        square.x = 15;
        square.y = Square.SIZE * 2.5;

        addEventListener(Event.ENTER_FRAME, onFrame);
    }

    // フレームごとに呼び出し。
    function onFrame(e:Event) {
        var change = new FloatChange(frameCount, frameCount + 1);
        change.handlePart(5, 25, updateSquare);
        frameCount++;
    }

    // 四角の位置を更新する。
    function updateSquare(part:FloatChangePart) {
        square.x = part.current.lerp(15, 435);
    }
}
---------

{{page.logo}}の説明として重要なのは以下のコードです。

[source,haxe]
---------
using tweenxcore.Tools;
---------

[source,haxe]
---------
// フレームごとに呼び出し。
function onFrame(e:Event) {
    var change = new FloatChange(frameCount, frameCount + 1);
    change.handlePart(5, 25, updateSquare);
    frameCount++;
}

// 四角の位置を更新する。
function updateSquare(part:FloatChangePart) {
    square.x = part.current.lerp(15, 435);
}
---------



それでは1つづつ要素を見ていきます。


==== tweenxcore.Tools

ここで読み込んでいるtweenxcore.Toolsモジュールは4種類のクラスを持っています。

Easingクラス::
  モーションの曲線として使われる、イージング関数を持ちます

FloatToolsクラス::
  Floatの機能を拡張します。

PointToolsクラス::
  XY座標上の点の拡張です。ベジェ曲線の機能を付け加えます。FlashのPointクラスに対してだけではなく、様々なライブラリのPoint型に対して使えます。

MatrixToolsクラス::
  XY座標のアフィン変換の行列の拡張です。2次元的な動きを相似変換するための機能を付け加えます。FlashのMatrixクラスに対してだけではなく、{sourceLink}tweenxcore/geom/Matrix.hx[似たインターフェース]を持つその他のライブラリのMatrix型に対して使えます。

``using tweenxcore.Tools;``で、このすべてを拡張として読みこみます。

{sourceLink}tweenxcore/Tools.hx[[ソースを見る(tweenxcore.Tools)\]]

==== FloatChange、FloatChangePart
``FloatChange``と``FloatChangePart``は`tweenxcore.structure`が提供している型で、直前のFloat値と現在のFloat値をまとめて1つの型に持つことで、値の変化を簡単に扱えるようにします。

この``FloatChange``の``handlePart``関数は、値が指定した範囲にあった場合にすぐに関数呼び出しを行います。つまり例では、``frame``または``frame + 1``が``0 < 値 < 20``の範囲にあるとき、``updateSquare``関数を呼び出します。

``FloatChangePart``は始まりの値が0.0で終わりの値が1.0であるような``FloatChange``です。例の``updateSquare``の引数は``frame``の5から25が、0.0から1.0の範囲に変換されたものとなっています。

``FloatChange``と``FloatChangePart``はどちらも変数``current``で現在の値を取得できます。``FloatChangePart``の場合、この値は``0.0 < current \<= 1.0``の範囲にあります。

* {sourceLink}tweenxcore/structure/FloatChange.hx[[ソースを見る(tweenxcore.structure.FloatChange)\]]
* {sourceLink}tweenxcore/structure/FloatChangePart.hx[[ソースを見る(tweenxcore.structure.FloatChangePart)\]]

==== lerp

``lerp`` は線形補間の関数で、``tweenxcore.Tools.FloatTools``が持つ関数です。0.0から1.0の値を指定した範囲の値、例の場合、15から435までの値に変換しています。これにより、``part.current``が0.0から1.0まで変化する間に、``square.x``は15から435へと移動します。





== {{page.logo}}チュートリアル

=== イージング関数

{% include sample.asciidoc num="400" title="EasingVisualizer" width=700 height=500 %}

{{page.logo}}は、link:http://easings.net/[Robert Pennerのイージング関数]を基本とし、中央で減速して再度加速する``OutIn``のモードと、瞬間的に移動を行うwarpが追加された計46個の関数を提供しています。

上の曲線としては一般的なトゥイーンライブラリとの違いはありませんが、コードの面では大きな違いがあります。

一般的なものでは、cubicInの関数は以下の形です。

[source,haxe]
---------
function cubicIn(t:Float, b:Float, c:Float, d:Float):Float {
    return c * (t /= d) * t * t + b;
}
---------

この関数には4つの引数があり、それぞれ

* ``t``は動き始めてからの経過時刻
* ``b``は値の初期値
* ``c``は値の変化量
* ``d``は完了までの時間

です。

一方、{{page.logo}}での``cubicIn``関数は以下の通りです。

[source,haxe]
---------
function cubicIn(t:Float):Float {
    return t * t * t;
}
---------

引数が1つだけという、ずっとシンプルな形です。

これは前に説明したとおり、{{page.logo}}の世界では**始まりの値は0.0であり、終わりの値は1.0**だからです。このルールでは、もとの4つの引数は以下のように考えることができます。

* ``t``は、経過時刻を0.0から1.0までで表したもの
* 値の初期値は0.0
* 値の変化量は1.0
* 完了までの時間は1.0

つまり、{{page.logo}}の世界では変数は``t``のみで、他は3つは定数と考えられます。

イージング関数に引数が4つもあると直接利用するには不便ですが、引数が1つになることでイージング関数を直接使っても何をやっているのかわかりやすくなります。

この関数を使って先ほどのサンプルコードにのイージングをつけてみます。たった1行、以下のように変更を加えます。

[source,haxe]
---------
square.x = part.current.cubicIn().lerp(15, 435);
---------

``part.current``の0.0から1.0までの値を、``cubicIn()``を使ってカーブをつけた後に、``lerp``関数で15から435の値に変換しています。{{page.logo}}を使用するコードでは、このようなFloatの値に対するメソッドチェーンがよく出てきます。

{% include sample.asciidoc num="302" title="Easing" %}

=== 基本的な動き

==== 繰り返し

1つのパートを、複数回繰り返したい場合、``handlePart``の代わりに``handleRepeatPart``を使います。

{% include sample.asciidoc num="303" title="Repeat" %}

[source,haxe]
---------
change.handleRepeatPart(5, 25, 3, updateSquare);
---------

このサンプルでは、5フレーム目から65フレーム目までの60フレームの間に``FloatChangePart``の0.0から1.0の移動が3回繰り返されています。

``handleRepeatPart``が``updateSquare``に引数として渡す``FloatChangePart``は``FloatChangeRepeatPart``として拡張したもので、現在が何回目の繰り返しかなどの追加の情報にアクセスができます。

{sourceLink}tweenxcore/structure/FloatChangeRepeatPart.hx[[ソースを見る(tweenxcore.structure.FloatChangeRepeatPart)\]]

==== ヨーヨー、ジグザグ

ヨーヨーとジグザグはどちらも0.0から1.0に行って0.0に帰ってくるようなモーションです。

{% include sample.asciidoc num="304" title="YoyoZigzag" %}

上がヨーヨー、下がジグザグのアニメーションです。ヨーヨーは戻るときに逆再生の動きをしますが、ジグザグは行きと同じイージングで戻ります。

それぞれ以下のように使います。

```haxe
// ヨーヨー
square1.x = part.current.yoyo(Easing.quadOut).lerp(15, 435);

// ジグザグ
square2.x = part.current.zigzag(Easing.quadOut).lerp(15, 435);
```

==== モーションの特定のタイミングに処理をする

``FloatChangePart``には、モーションの開始タイミングや、終了タイミングを取得するための関数が用意されています。

{% include sample.asciidoc num="305" title="CrossOver" %}

この例では、パートの開始のタイミング、真ん中のタイミング、終了のタイミングのみ``true``になるフラグを使って各タイミングで色を変えています。

```haxe
function updateSquare(part:FloatChangePart) {
	square.x = part.current.cubicIn().lerp(15, 435);

	// パートの開始タイミングだったら、赤に変更
	if (part.isEntrance())
	{
		square.transform.colorTransform = new ColorTransform(0, 0, 0, 1, 0xFF, 0x78, 0x78);
	}

	// パートが半分経過したタイミングだったら、緑に変更
	if (part.isCrossOver(0.5))
	{
		square.transform.colorTransform = new ColorTransform(0, 0, 0, 1, 0x78, 0xFF, 0x78);
	}

	// パートの終了タイミングだったら、青に変更
	if (part.isExit())
	{
		square.transform.colorTransform = new ColorTransform(0, 0, 0, 1, 0x78, 0x78, 0xFF);
	}
}
```

====　連続したモーションをあつかう

連続したモーションをあつかうには、``FloatChange``の``handleTimelinePart``が使えます。

{% include sample.asciidoc num="306" title="TimelinePart" %}

右、下、左の三つの移動を行いました。

```haxe
var timeline:Timeline<FloatChangeTimelinePart->Void>;

public function new() {
    // (中略)
	
    // 重み付きのupdate関数の配列を作成。
    timeline = new Timeline().add(update1, 1).add(update2, 3).add(update3, 12);
}

function onFrame(e:Event) {
    var change = new FloatChange(frameCount, frameCount += 1);

    // Timelineに合わせて、update関数呼び出し。
    change.handleTimelinePart(0, 80, timeline);
}

function update1(change:FloatChangeTimelinePart) {
    // 右へ移動
    square.x = change.current.lerp(15, 435);
}

function update2(change:FloatChangeTimelinePart) {
    // 下へ移動
    square.y = change.current.cubicInOut().lerp(15, 135);
}

function update3(change:FloatChangeTimelinePart) {
    // 左へ移動
    square.x = change.current.quartIn().cubicIn().lerp(435, 15);
}
```

``Timeline``は重み付きの配列です。配列の各要素に``Float``で重みがつけられています。サンプルでは``update1, update2, update3``に``1:3:12``の重みを付けています。

``handleTimelinePart``は、この重みに従ってupdate関数を呼び出します。サンプルでは、5フレームかけて``update1``を、15フレームかけて``update2``を、60フレームかけて``update3``を呼び出しています。

``FloatChangeTimelinePart``は``FloatChangePart``を継承しており、現在タイムラインのどの位置にいるかなどの情報が追加で取得できます。

{sourceLink}tweenxcore/structure/FloatChangeTimelinePart.hx[[ソースを見る(tweenxcore.structure.FloatChangeTimelinePart)\]]

=== イージングを自作する

{{page.logo}}には46種類のイージングありますがこれらを単に使うだけでは、ありふれた退屈なモーションになりがちです。{{page.logo}}ではイージングを組み合わせたり混ぜ合わせたりして自分だけのイージングを作り出すことができます。

==== 多重のイージング

イージングを2重、3重に使うと、新しい動きを作ることができます。

{% include sample.asciidoc num="307" title="Composite" %}

```haxe
// 上
square1.x = part.current.quintInOut().quintInOut().lerp(15, 435);

// 下
square2.x = part.current.cubicIn().bounceOut().lerp(15, 435);
```

上は``quintInOut``を2重に使ってより急激な加速減速を作っており、下は``cubicIn``と``bounceOut``で加速していくバウンドのイージングを作っています。

==== ミックス

``mixEasing``は2つのイージングの中間的なイージングです。

{% include sample.asciidoc num="308" title="Mix" %}

```haxe
square.x = part.current.mixEasing(Easing.expoOutIn, Easing.linear, 0.15).lerp(15, 435);
```

サンプルとしてゲームのカットイン演出にありそうなイージングを作りました。``expoOutIn``に``linear``関数を``0.15``ミックスすることで、``OutIn``のイージングの真ん中でピタッっと止まる感じを無くしています。

==== クロスフェード

``crossfadeEasing``は、始まりと終わりで別のイージングに徐々に変わっていくようなイージングです。

{% include sample.asciidoc num="309" title="Crossfade" %}

```haxe
square.x = part.current.crossfadeEasing(
    Easing.quintOut,
    Easing.bounceOut,
    Easing.sineInOut
).lerp(15, 435);
```

サンプルは``quintOut``として始まって、徐々に``Easing.bounceOut``に変わっていくイージングです。変化の仕方の曲線として``Easing.sineInOut``を使っています。

==== コネクト

``connectEasing``は、2つのイージングをつなげて再生する機能です。

{% include sample.asciidoc num="310" title="Connect" %}

```haxe
square.x = part.current.connectEasing(Easing.backOut, 0.9, 0.4, Easing.linear).lerp(15, 435);
```

サンプルでは、最初の``0.9``の時間で``0.4``の位置まで``backOut``で移動した後、残りを``linear``で移動しています。

==== ワンツー

``oneTwoEasing``は、別々のイージングで2回移動を行うイージングです。

{% include sample.asciidoc num="311" title="OneTwo" %}

```haxe
// 上
square1.x = part.current.oneTwoEasing(Easing.backIn, 0.8, Easing.linear).lerp(45, 405);

// 中
square2.x = part.current.oneTwoEasing(
    function (r:Float) { return r.yoyo(Easing.cubicOut).lerp(0, 0.3); },
    0.9,
    Easing.linear
).lerp(45, 405);

// 下
square3.x = part.current.oneTwoEasing(
    function (r:Float) { return r.backOut(); },
    0.8,
    function (r:Float) { return r.revert().sineIn(); }
).lerp(45, 405);
```

サンプルの一番上は単純に別々のイージングを使って2回移動を行っています。ワンツーのイージングはこのような単純な使い方よりも、真ん中や下の例のように``yoyo``、``zigzag``、``revert``などの関数と合わせて往復をするようなイージングを作るのに適しています。

=== CustomEasingクラス

このようなイージングのカスタム機能を何度も使う場合、自作のイージングをまとめたCustomEasingクラスを作っておくと便利です。

```haxe
using tweenxcore.Tools;

class CustomEasing {
    public static inline function quintQuintInOut(rate:Float) {
       return rate.quintInOut().quintInOut();
    }
}
```

このように``CustomEasing``クラスを定義しておけば、自分の作ったイージングを``using packageName.CustomEasing;``して簡単に利用できるようになります。


=== 応用

ここまでのまとめのサンプルです。

{% include sample.asciidoc num="312" title="CustomEasing" %}

このようにカスタムイージングの機能を使えるようになれば、新しくて気持ちのよいモーションを簡単に作ることができるようになります。

=== 2次元の動き

==== マトリックス

いままでのモーションはすべてX方向の動きをあつかってきましたが、Y方向の動きも入れてみます。

{% include sample.asciidoc num="313" title="Xy" %}

```haxe
square.x = part.current.expoOutIn().lerp(15, 435);
square.y = part.current.sinByRate().lerp(75, 95);
```

四角をY方向に揺らしてみました。ここで使っている``sinByRate``はラジアンの代わりに円の一周を1.0としてあつかう``sin``関数です。

このサンプルはそれほど目新しくはありません。問題となるのは同じようなモーションを斜め方向に行う場合です。これまで0.0から1.0の値を実際の``x``座標に変換するのには``lerp``関数を使ってきましたが、回転が加わる場合``lerp``関数は使えません。

そういった場合は、``MatrixTools.createSimilarityTransform``を使います。

{% include sample.asciidoc num="314" title="Matrix" %}

```haxe
var matrix:flash.geom.Matrix;

public function new() {
	// (中略)

	// X座標を100から350、Y座標を15から135に移動するための行列を作成
	matrix = new flash.geom.Matrix();
	matrix.createSimilarityTransform(100, 15, 350, 135);
}

function updateSquare(part:FloatChangePart) {
	var x = part.current.expoOutIn();
	var y = part.current.sinByRate().lerp(0, 0.1);
	var point = matrix.transformPoint(new Point(x, y));

	square.x = point.x;
	square.y = point.y;
}
```

``createSimilarityTransform(fromX, fromY, toX, toY)``は、X方向の0.0から1.0までの移動を、X方向に``fromX``から``toX``Y方向に``fromY``から``toY``の移動に相似変換するような行列を作成します。

==== 極座標
==== ベジェ曲線

=== いろんなものを動かす
==== RGBカラー、HSVカラー
==== 画像
