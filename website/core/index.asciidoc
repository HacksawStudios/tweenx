---
layout: default
title: TweenXCore - lightweight motion library for haxe
logo: +++<span class="tweenxcore">TweenX<span class="core">Core</span></span>+++
---
:showtitle:
:author: shohei909
:toc: macro
:toc-title: 目次
:toclevels: 4
:sampleLink: link:https://github.com/shohei909/tweenx/blob/develop/sample/
:sourceLink: link:https://github.com/shohei909/tweenx/blob/develop/src/tweenxcore/
:page-liquid:

= {{page.logo}}

{{page.logo}}は https://haxe.org/[Haxe] で気持ちの良いモーションをより簡単に作成するための、シンプルな**トゥイーンライブラリ**です。

実行速度を速く、開発速度を速く、バグを少なく、学習コストを少なく、そしてモーションを自由に面白くするために作られています。

**「ここにカッコいいデモ(予定)」**

toc::[]

== 機能

* 44種類のイージング関数
* 繰り返し
* ヨーヨー、ジグザグ運動
* イージングのミックス、クロスフェード、連結などのカスタム機能
* HSVカラー、RGBカラー
* 極座標
*　ベジェ曲線
*　``lerp``、``inverseLerp``、``clamp``など、``Float``の機能の拡張



== 速度

Flashプラットフォーム上で動作する高速なトゥイーンライブラリとして名高いBetweenAS3よりも、さらに高速に動作しています。

{sampleLink}tweenx/800_BenchMark/src[[コードを見る(Github)\]]



== {{page.logo}}の思想

=== 脱インタープリタ

Flashプラットフォームで流行したトゥイーンライブラリはどれも内部にトゥイーンを実行するインタープリタを持ち、ユーザーはそれに対してトゥイーンの処理を登録していきます。


しかし、このようなインタープリタはバグの温床になりやすいものです。

× 同じオブジェクトに対して2つのトゥイーンが走ったときの挙動は混乱を生みます。
× 常にメモリリークを気にかけながら実装を行う必要があります。
× イベントハンドラの取り扱いも厄介です。

インタープリタはとりあえず動くコードを書くのに便利で、プロトタイプや小さなゲームを作るのに向いていますが、もっと大きな製品を作る場合は事情が違います。

例えば

* ゲームの場合、**「一時停止ボタンが押されたときにゲーム内のアニメーションをすべて一時停止した上で、さらにアニメーション付きでポップアップを表示させたい」**ことがあります。
* 通信待ちのインジケータなら、**「インジケータのフェードイン中に通信が終われば、フェードインの途中からフェードアウトに切り替えをしたい」**と思うはずです。

これらはインタープリタの苦手分野です。

もちろん http://tweenx.spheresofa.net/[TweenX] はそういった用途にも耐えうるように細心の注意をはらって設計していますが、そういったものを作るにはインタープリタの動作を詳細に知らなくてはいけませんし、新しい言語を覚えるような大きい学習コストもかかります。製作者のわたし自身もTweenXのバックグラウンドで何かをやってくれるような機能は使わなくなり、TweenXのイージング関数を直接使ってモーションのコードを書くようになっていました。

そして、staticな関数群といくつかの頻出な構造体だけを用意してあれば、自由で簡単で高速なトゥイーンライブラリができることに気が付きました。そうして作られたのが{{page.logo}}です。


=== 0.0から始まり、1.0で終わる

{{page.logo}}の世界では、始まりの値は0.0であり、終わりの値は1.0です。つまり、

* モーションの時刻の場合、開始時刻は0.0で表し終了時刻は1.0を使います。
* アルファ値の場合、完全な透明は0.0で完全な不透明は1.0です。
* 円の1周の場合、0度は0.0であり360度は1.0です。
* RGBカラーのRed値の場合、0.0が赤みが全くなく1.0が完全な赤です。

{{page.logo}}では、このような0.0から1.0を基準とする値について``rate``という変数名をよく使います。

{{page.logo}}は、**この0.0から1.0を基準とする値を、自由にあやつるためのツール**だと考えてください。



=== オープンソース

MITライセンスですので、商用、非商用、個人、法人を問わず、利用、改変、再配布ができます。



== {{page.logo}}を始める

=== Haxeバージョン

http://haxe.org/[Haxe]の3.1.3以降をサポートしています。


=== インストール

Haxeのインストール後、コマンドラインから以下のコマンドを入力してください。

[source, shell]
---------
haxelib install tweenxcore
---------

=== Hello {{page.logo}}

{{page.logo}}の最初のサンプルとして四角のx座標を0から420まで、動かすコードを見てみます。

{% include sample.asciidoc num="301" title="Simplest" %}

[source,haxe,linenums]
---------
import flash.display.Sprite;
import flash.events.Event;
import sample.SampleSuport.Square;
import tweenxcore.structure.FloatChange;
import tweenxcore.structure.FloatChangePart;
using tweenxcore.Tools;

class Sample extends Sprite {
    public static inline var MOTION_END = 60;
    var square:Square;
    var frameCount = 0;

    public function new() {
        super();
        addChild(square = new Square());
        square.x = 15;
        square.y = Square.SIZE * 2.5;

        addEventListener(Event.ENTER_FRAME, onFrame);
    }

    // フレームごとに呼び出し。
    function onFrame(e:Event) {
        var change = new FloatChange(frameCount, frameCount + 1);
        change.handlePart(5, 25, updateSquare);
        frameCount++;
    }

    // 四角の位置を更新する。
    function updateSquare(part:FloatChangePart) {
        square.x = part.current.lerp(15, 435);
    }
}
---------

サンプルはFlashプラットフォームのコードですが、他のプラットフォームであっても{{page.logo}}の使い方はほとんど変わりません。

{{page.logo}}の説明として重要なのは以下のコードです。

[source,haxe]
---------
using tweenxcore.Tools;
---------

[source,haxe]
---------
// フレームごとに呼び出し。
function onFrame(e:Event) {
    var change = new FloatChange(frameCount, frameCount + 1);
    change.handlePart(5, 25, updateSquare);
    frameCount++;
}

// 四角の位置を更新する。
function updateSquare(part:FloatChangePart) {
    square.x = part.current.lerp(15, 435);
}
---------



それでは1つづつ要素を見ていきます。


==== using tweenxcore.Tools

ここで読み込んでいる``tweenxcore.Tools``モジュールは4種類のクラスを持っています。

Easingクラス::
  モーションの曲線として使われる、イージング関数を持ちます

FloatToolsクラス::
  Floatの機能を拡張します。

PointToolsクラス::
  XY座標上の点の拡張です。ベジェ曲線の機能を付け加えます。Flashの``Point``クラスに対してだけではなく、様々なライブラリの``Point``型に対して使えます。

MatrixToolsクラス::
  XY座標のアフィン変換の行列の拡張です。2次元的な動きを相似変換するための機能を付け加えます。Flashの``Matrix``クラスに対してだけではなく、{sourceLink}tweenxcore/geom/Matrix.hx[似たインターフェース]を持つその他のライブラリの``Matrix``型に対して使えます。

``using tweenxcore.Tools;``でこのすべてを拡張として読みこみます。

チュートリアルで紹介する関数の多くはこの``Tools``のモジュールにありますから、そのソースを参照しながら読み進めると理解がしやすいかと思います。

{sourceLink}tweenxcore/Tools.hx[[ソースを見る(tweenxcore.Tools)\]]

==== FloatChange、FloatChangePart
``FloatChange``と``FloatChangePart``は``tweenxcore.structure``パッケージに含まれる型です。

``FloatChange``は直前の``Float``値と現在の``Float``値をまとめて1つの型に持つことで、値の変化を簡単にあつかえるようにします。

この``FloatChange``の``handlePart``関数は、値が指定した範囲にあった場合にすぐに関数呼び出しを行います。つまり例では、``frame``または``frame + 1``が``0 < 値 < 20``の範囲にあるとき、``updateSquare``関数を呼び出します。

``FloatChangePart``は始まりの値が0.0で終わりの値が1.0であるような``FloatChange``です。例の``updateSquare``の引数は``frame``の5から25が、0.0から1.0の範囲に変換されたものとなっています。

``FloatChange``と``FloatChangePart``はどちらも変数``current``で現在の値を取得できます。``FloatChangePart``の場合、この値は``0.0 < current \<= 1.0``の範囲にあります。

* {sourceLink}tweenxcore/structure/FloatChange.hx[[ソースを見る(tweenxcore.structure.FloatChange)\]]
* {sourceLink}tweenxcore/structure/FloatChangePart.hx[[ソースを見る(tweenxcore.structure.FloatChangePart)\]]

==== lerp

``lerp`` は線形補間の関数で、``tweenxcore.Tools.FloatTools``が持つ関数です。0.0から1.0の値を指定した範囲の値、例の場合、15から435までの値に変換しています。これにより、``part.current``が0.0から1.0まで変化する間に、``square.x``は15から435へと移動します。





== {{page.logo}}チュートリアル

=== イージング関数

{% include sample.asciidoc num="400" title="EasingVisualizer" width=700 height=500 %}

{{page.logo}}は、link:http://easings.net/[Robert Pennerのイージング関数]を基本とし、中央で減速して再度加速する``OutIn``のモードと、瞬間的に移動を行うwarpが追加された計44個の関数を提供しています。

上の曲線としては一般的なトゥイーンライブラリとの違いはありませんが、コードの面では大きな違いがあります。

一般的なものでは、cubicInの関数は以下の形です。

[source,haxe]
---------
function cubicIn(t:Float, b:Float, c:Float, d:Float):Float {
    return c * (t /= d) * t * t + b;
}
---------

この関数には4つの引数があり、それぞれ

* ``t``は動き始めてからの経過時刻
* ``b``は値の初期値
* ``c``は値の変化量
* ``d``は完了までの時間

です。

一方、{{page.logo}}での``cubicIn``関数は以下の通りです。

[source,haxe]
---------
function cubicIn(t:Float):Float {
    return t * t * t;
}
---------

引数が1つだけという、ずっとシンプルな形です。

これは前に説明したとおり、{{page.logo}}の世界では**始まりの値は0.0であり、終わりの値は1.0**だからです。このルールでは、もとの4つの引数は以下のように考えることができます。

* ``t``は、経過時刻を0.0から1.0までで表したもの
* 値の初期値は0.0
* 値の変化量は1.0
* 完了までの時間は1.0

つまり、{{page.logo}}の世界では変数は``t``のみで、他は3つは定数と考えられます。

イージング関数に引数が4つもあると直接利用するには不便ですが、引数が1つになることでイージング関数を直接使っても何をやっているのかわかりやすくなります。

この関数を使って先ほどのサンプルコードにのイージングをつけてみます。たった1行、以下のように変更を加えます。

[source,haxe]
---------
square.x = part.current.cubicIn().lerp(15, 435);
---------

``part.current``の0.0から1.0までの値を、``cubicIn()``を使ってカーブをつけた後に、``lerp``関数で15から435の値に変換しています。{{page.logo}}を使用するコードでは、このようなFloatの値に対するメソッドチェーンがよく出てきます。

{% include sample.asciidoc num="302" title="Easing" %}

=== 基本的な動き

==== 繰り返し

1つのパートを、複数回繰り返したい場合、``handlePart``の代わりに``handleRepeatPart``を使います。

{% include sample.asciidoc num="303" title="Repeat" %}

[source,haxe]
---------
change.handleRepeatPart(5, 25, 3, updateSquare);
---------

このサンプルでは、5フレーム目から65フレーム目までの60フレームの間に``FloatChangePart``の0.0から1.0の移動が3回繰り返されています。

``handleRepeatPart``が``updateSquare``に引数として渡す``FloatChangePart``は``FloatChangeRepeatPart``として拡張したもので、現在が何回目の繰り返しかなどの追加の情報にアクセスができます。

{sourceLink}tweenxcore/structure/FloatChangeRepeatPart.hx[[ソースを見る(tweenxcore.structure.FloatChangeRepeatPart)\]]

==== ヨーヨー、ジグザグ

ヨーヨーとジグザグはどちらも0.0から1.0に行って0.0に帰ってくるようなモーションです。

{% include sample.asciidoc num="304" title="YoyoZigzag" %}

上がヨーヨー、下がジグザグのアニメーションです。ヨーヨーは戻るときに逆再生の動きをしますが、ジグザグは行きと同じイージングで戻ります。

それぞれ以下のように使います。

```haxe
// ヨーヨー
square1.x = part.current.yoyo(Easing.quadOut).lerp(15, 435);

// ジグザグ
square2.x = part.current.zigzag(Easing.quadOut).lerp(15, 435);
```

==== モーションの特定のタイミングに処理をする

``FloatChangePart``には、モーションの開始タイミングや、終了タイミングを取得するための関数が用意されています。

{% include sample.asciidoc num="305" title="CrossOver" %}

この例では、パートの開始のタイミング、真ん中のタイミング、終了のタイミングのみ``true``になるフラグを使って各タイミングで色を変えています。

```haxe
function updateSquare(part:FloatChangePart) {
	square.x = part.current.cubicIn().lerp(15, 435);

	// パートの開始タイミングだったら、赤に変更
	if (part.isEntrance())
	{
		square.transform.colorTransform = new ColorTransform(0, 0, 0, 1, 0xFF, 0x78, 0x78);
	}

	// パートが半分経過したタイミングだったら、緑に変更
	if (part.isCrossOver(0.5))
	{
		square.transform.colorTransform = new ColorTransform(0, 0, 0, 1, 0x78, 0xFF, 0x78);
	}

	// パートの終了タイミングだったら、青に変更
	if (part.isExit())
	{
		square.transform.colorTransform = new ColorTransform(0, 0, 0, 1, 0x78, 0x78, 0xFF);
	}
}
```

====　連続したモーションをあつかう

連続したモーションをあつかうには、``FloatChange``の``handleTimelinePart``が使えます。

{% include sample.asciidoc num="306" title="TimelinePart" %}

右、下、左の三つの移動を行いました。

```haxe
var timeline:Timeline<FloatChangeTimelinePart->Void>;

public function new() {
    // (中略)

    // 重み付きのupdate関数の配列を作成。
    timeline = new Timeline().add(update1, 1).add(update2, 3).add(update3, 12);
}

function onFrame(e:Event) {
    var change = new FloatChange(frameCount, frameCount += 1);

    // Timelineに合わせて、update関数呼び出し。
    change.handleTimelinePart(0, 80, timeline);
}

function update1(change:FloatChangeTimelinePart) {
    // 右へ移動
    square.x = change.current.lerp(15, 435);
}

function update2(change:FloatChangeTimelinePart) {
    // 下へ移動
    square.y = change.current.cubicInOut().lerp(15, 135);
}

function update3(change:FloatChangeTimelinePart) {
    // 左へ移動
    square.x = change.current.quartIn().cubicIn().lerp(435, 15);
}
```

``Timeline``は重み付きの配列です。配列の各要素に``Float``で重みがつけられています。サンプルでは``update1, update2, update3``に``1:3:12``の重みを付けています。

``handleTimelinePart``は、この重みに従ってupdate関数を呼び出します。サンプルでは、5フレームかけて``update1``を、15フレームかけて``update2``を、60フレームかけて``update3``を呼び出しています。

``FloatChangeTimelinePart``は``FloatChangePart``を継承しており、現在タイムラインのどの位置にいるかなどの情報が追加で取得できます。

{sourceLink}tweenxcore/structure/FloatChangeTimelinePart.hx[[ソースを見る(tweenxcore.structure.FloatChangeTimelinePart)\]]

=== イージングを自作する

{{page.logo}}には46種類のイージングありますがこれらを単に使うだけでは、ありふれた退屈なモーションになりがちです。{{page.logo}}ではイージングを組み合わせたり混ぜ合わせたりして自分だけのイージングを作り出すことができます。

==== 多重のイージング

イージングを2重、3重に使うと、新しい動きを作ることができます。

{% include sample.asciidoc num="307" title="Composite" %}

```haxe
// 上
square1.x = part.current.quintInOut().quintInOut().lerp(15, 435);

// 下
square2.x = part.current.cubicIn().bounceOut().lerp(15, 435);
```

上は``quintInOut``を2重に使ってより急激な加速減速を作っており、下は``cubicIn``と``bounceOut``で加速していくバウンドのイージングを作っています。

==== ミックス

``mixEasing``は2つのイージングの中間的なイージングです。

{% include sample.asciidoc num="308" title="Mix" %}

```haxe
square.x = part.current.mixEasing(Easing.expoOutIn, Easing.linear, 0.12).lerp(15, 435);
```

サンプルとしてゲームのカットイン演出にありそうなイージングを作りました。``expoOutIn``に``linear``関数を``0.12``ミックスすることで、``OutIn``のイージングの真ん中でピタッっと止まる感じを無くしています。

==== クロスフェード

``crossfadeEasing``は、始まりと終わりで別のイージングに徐々に変わっていくようなイージングです。

{% include sample.asciidoc num="309" title="Crossfade" %}

```haxe
square.x = part.current.crossfadeEasing(
    Easing.quintOut,
    Easing.bounceOut,
    Easing.sineInOut
).lerp(15, 435);
```

サンプルは``quintOut``として始まって、徐々に``Easing.bounceOut``に変わっていくイージングです。変化の仕方の曲線として``Easing.sineInOut``を使っています。

==== コネクト

``connectEasing``は、2つのイージングをつなげて再生する機能です。

{% include sample.asciidoc num="310" title="Connect" %}

```haxe
square.x = part.current.connectEasing(Easing.backOut, 0.9, 0.4, Easing.linear).lerp(15, 435);
```

サンプルでは、最初の``0.9``の時間で``0.4``の位置まで``backOut``で移動した後、残りを``linear``で移動しています。

==== ワンツー

``oneTwoEasing``は、別々のイージングで2回移動を行うイージングです。

{% include sample.asciidoc num="311" title="OneTwo" %}

```haxe
// 上
square1.x = part.current.oneTwoEasing(Easing.backIn, 0.8, Easing.linear).lerp(45, 405);

// 中
square2.x = part.current.oneTwoEasing(
    function (r:Float) { return r.yoyo(Easing.cubicOut).lerp(0, 0.3); },
    0.9,
    Easing.linear
).lerp(45, 405);

// 下
square3.x = part.current.oneTwoEasing(
    function (r:Float) { return r.backOut(); },
    0.8,
    function (r:Float) { return r.revert().sineIn(); }
).lerp(45, 405);
```

サンプルの一番上は単純に``backIn``で1回目の``linear``で2回目の移動を行っています。ワンツーのイージングはこのような単純な使い方よりも、真ん中や下の例のように``yoyo``、``zigzag``、``revert``などの関数と合わせて往復をするようなイージングを作るのに適しています。

=== CustomEasingクラス

このようなイージングのカスタム機能を何度も使う場合、自作のイージングをまとめたCustomEasingクラスを作っておくと便利です。

```haxe
using tweenxcore.Tools;

class CustomEasing {
    public static inline function quintQuintInOut(rate:Float) {
       return rate.quintInOut().quintInOut();
    }
}
```

このように``CustomEasing``クラスを定義しておけば、自分の作ったイージングを``using packageName.CustomEasing;``して簡単に利用できるようになります。


=== 応用

ここまでの機能を合わせて使ったサンプルです。

{% include sample.asciidoc num="312" title="CustomEasing" %}

このようにカスタムイージングを使えるようになれば、新しくて気持ちのよいモーションを簡単に作ることができるようになります。

=== 2次元の動き

==== マトリックス

いままでのモーションはすべてX方向の動きをあつかってきましたが、Y方向の動きも入れてみます。

{% include sample.asciidoc num="313" title="Xy" %}

```haxe
square.x = part.current.expoOutIn().lerp(15, 435);
square.y = part.current.sinByRate().lerp(75, 95);
```

四角をY方向に揺らしてみました。ここで使っている``sinByRate``は円の一周を1.0としてあつかう``sin``関数です。

このサンプルはそれほど目新しくはありません。問題は同じようなモーションを斜め方向に行う場合です。これまで0.0から1.0の値を実際の``x``座標に変換するのには``lerp``関数を使ってきましたが、回転が加わる場合``lerp``関数は使えません。

そういった場合は、``MatrixTools.createSimilarityTransform``を使います。

{% include sample.asciidoc num="314" title="Matrix" %}

```haxe
var matrix:flash.geom.Matrix;

public function new() {
	// (中略)

	// X座標を100から350、Y座標を15から135に移動するための行列を作成
	matrix = new flash.geom.Matrix();
	matrix.createSimilarityTransform(100, 15, 350, 135);
}

function updateSquare(part:FloatChangePart) {
	var x = part.current.expoOutIn();
	var y = part.current.sinByRate().lerp(0, 0.1);
	var point = matrix.transformPoint(new Point(x, y));

	square.x = point.x;
	square.y = point.y;
}
```

``createSimilarityTransform(fromX, fromY, toX, toY)``は、X方向の0.0から1.0までの移動を、X方向に``fromX``から``toX``Y方向に``fromY``から``toY``の移動に相似変換するような行列を作成します。

==== 極座標

{{page.logo}}は極座標をサポートしています。

{% include sample.asciidoc num="315" title="Polar" %}

```haxe
var matrix:Matrix;

public function new() {
	// (中略)

	// 相似変換を作成
	matrix = new Matrix();
	matrix.createSimilarityTransform(225, 75, 15, 15);
}

function updateSquare(part:FloatChangePart) {
	// 原点に近づいていく
	var distance = part.current.expoOut().lerp(1, 0);
	// 反時計回りに2周する。
	var angle = part.current.lerp(0, -2);
	var polarPoint = new PolarPoint(distance, angle);

	// 実際の座標へ変換
	var point = matrix.transformPoint(new Point(polarPoint.x, polarPoint.y));
	square.x = point.x;
	square.y = point.y;
}
```

サンプルは、``(x, y)=(225, 75)``を極座標の中心として、そこに``(x, y)=(15, 15)``の位置から回転しながら近づいていくモーションです。

{sourceLink}tweenxcore/geom/PolarPoint.hx[[ソースを見る(tweenxcore.geom.PolarPoint)\]]

==== ベジェ曲線

{{page.logo}}はベジェ曲線もサポートしています。

{% include sample.asciidoc num="316" title="Bezier" %}

```haxe
square.x = part.current.bezier3(15, 50, 400, 435);
square.y = part.current.bezier3(15, 200, -50, 135);
```

サンプルは、始点が``(15, 15)``、制御点が``(50, 200)``と``(400, -50)``、終点が``(400, 135)``の3次ベジェ曲線です。

ベジェ曲線は3次だけでなく任意の次数ののベジェ曲線が使えます。詳しくは``tweenxcore.Tools``モジュールを確認してください。

{sourceLink}tweenxcore/Tools.hx[[ソースを見る(tweenxcore.Tools)\]]


=== いろんなものを動かす

==== RGBカラー、HSVカラー

{{page.logo}}では、RGBカラーとHSVカラーが使えます。

{% include sample.asciidoc num="317" title="Color" %}

```haxe
var prevX = part.previous.expoInOut().lerp(0, 450);
var currentX = part.current.expoInOut().lerp(0, 450);

// RGB
var rgbCurve = part.current.expoInOut();
var red = rgbCurve.lerp(0.8, 0.7);
var green = rgbCurve.lerp(0.7, 1);
var blue = rgbCurve.lerp(0.5, 1);
graphics.beginFill(new RgbColor(red, green, blue).toInt());
graphics.drawRect(prevX, 30, currentX - prevX, 30);

// HSV
var hsvCurve = part.current.expoInOut();
var hue = hsvCurve.lerp(0.0, 1.0);
var saturation = hsvCurve.lerp(0.0, 0.8);
var value = 0.95;
graphics.beginFill(new HsvColor(hue, saturation, value).toInt());
graphics.drawRect(prevX, 90, currentX - prevX, 30);
```

サンプルはRGBと、HSVのそれぞれの値を動かしながら帯を描いています。

{sourceLink}tweenxcore/color[[ソースを見る(tweenxcore.color)\]]

==== 画像

連続したモーションをあつかうのに重み付き配列の``Timeline``を紹介しましたが、この``Timeline``は画像のパラパラアニメーションを作るのにも使えます。

{% include sample.asciidoc num="318" title="Bitmap" width="151" %}
