---
layout: default
title: TweenXCore - lightweight motion library for haxe
tweenxcore: +++<span class="tweenxcore">TweenX<span class="core">Core</span></span>+++
---
:showtitle:
:author: shohei909
:toc: macro
:toc-title: 目次
:toclevels: 4
:sampleLink: link:https://github.com/shohei909/tweenx/blob/develop/sample/
:sourceLink: link:https://github.com/shohei909/tweenx/blob/develop/src/tweenxcore/
:page-liquid:

= {{page.tweenxcore}}

{{page.tweenxcore}} is a cross-platform tween library for easier creation of pleasant motion with https://haxe.org/[Haxe].

It is designed to make execution speed faster, development speed faster, less buggy, less learning cost, and motion interesting.

++++
<div><canvas class="movie" id="CustomEasingSample" /></canvas></div>
++++

toc::[]

== Feature

* 44 kinds of easing function
* Yoyo, zigzag movement
* Custom functions such as easing mix, crossfade, concatenation
* HSV color, RGB color
* Polar coordinates
* Bezier curve
* Static extension of `` Float``, such as `` lerp``, `` inverseLerp``, `` clamp``
* Cooperation with link:./custom/[custom easing tool]

== Benchmark

{{page.tweenxcore}} does not do any extra processing or instance creation, so it works very fast.

The following is a comparison with each tween library on the Flash platform. We measured the FPS when tweeding 250000 objects at the same time.

image::/images/benchmark1.png[Result of benchmark]

link:/sample/bench1/TweensyBench.swf?width=401&height=401[[Tweensy\]] +
link:/sample/bench1/TweenXBench.swf?width=401&height=401[[TweenX\]] +
link:/sample/bench1/ActuateBench.swf?width=401&height=401[[Actuate\]] +
link:/sample/bench1/BetweenAS3Bench.swf?width=401&height=401[[BetweenAS3\]] +
link:/sample/bench1/TweenXCoreBench.swf?width=401&height=401[[TweenXCore\]]

{sampleLink}tweenx/800_BenchMark/src[[View source(Github)\]]


== License

MIT License


== Start {{page.tweenxcore}}

=== Haxe version

http://haxe.org/[Haxe] 3.1.3 or later is supported.


=== Installation

After installing Haxe, enter the following command on the command line interface.

[source, shell]
---------
haxelib install tweenxcore
---------

=== Hello {{page.tweenxcore}}

As the first sample of {{page.tweenxcore}}, let's look at the code to move the rectangular x coordinate from 0 to 450.

{% include sample.asciidoc lang="en" id="Simplest" %}

[source,haxe,linenums]
---------
import sample.Sprite;
import sample.Square;
using tweenxcore.Tools;

class SimplestSample extends Sprite {
    public static var TOTAL_FRAME:Int = 20;
    private var square:Square;
    private var frameCount = 0;

    public function new() {
        super();
        
        // Place a square in the initial position
        addChild(square = new Square());
        square.y = Square.SIZE * 2.0;
    }

    // Call this function every frame
    public function update():Void {
        var rate = frameCount / TOTAL_FRAME;
        
        // An animation when rate is 0 to 1.
        if (rate <= 1) {
            // Move x from 0 to 450 according to the value of rate.
            square.x = rate.quintOut().lerp(0, 450);
        }
        frameCount++;
    }
}
---------

The code related to {{page.tweenxcore}} is the following part.

[source,haxe]
---------
using tweenxcore.Tools;
---------

[source,haxe]
---------
square.x = rate.quintOut().lerp(0, 450);
---------



Let's look at each one one by one.


==== using tweenxcore.Tools

The `` tweenxcore.Tools`` module that we load here has four classes.

Easing class ::
   It has easing functions used as a curve of motion

FloatTools class ::
   Static extension of Float.

PointTools class ::
   Static extension of point on XY coordinates. For example, Bezier curve. It can be used not only for the `` Point`` class in Flash, but also for `` Point`` types in various libraries.

MatrixTools class ::
   Extension of matrix of affine transformation of XY coordinates. It adds a function for similarity transformation of two-dimensional motion. It can be used not only for the Flash `` Matrix`` class but also for the `` Matrix`` type of other library with {sourceLink}tweenxcore/geom/Matrix.hx[similar interface].

``using tweenxcore.Tools;`` will read this all as an extension.

Many of the functions introduced in the tutorial are in the module of this ``Tools``, so I think whether it is easier to understand by reading the source.

{sourceLink}tweenxcore/Tools.hx[[View source(tweenxcore.Tools)\]]


==== Easing function

``quintOut`` is an easing function. It changes the value of ``rate`` which changes from 0 to 1 to the value after the quintic function.

Of course not only ``quintOut`` is the easing function provided by {{page.tweenxcore}}.

Based on the link:http://easings.net/[Robert Penner's easing function], {{page.tweenxcore}} provides a total of 44 functions include ``OutIn`` mode which decelerates at the center and accelerates again, and ``warp`` which instantaneously moves.
    
{% include sample.asciidoc lang="en" id="EasingVisualize" %}

Let's see a bit of the implementation of these functions.

The `` cubicIn`` function in {{page.tweenxcore}} is as follows.

[source,haxe]
---------
function cubicIn(t:Float):Float {
    return t * t * t;
}
---------

It is a simple function that receives a Float and returns Float.

Let's replace the easing of the previous sample code with this function. Just one line, make the changes as follows.

[source,haxe]
---------
square.x = rate.cubicIn().lerp(0, 450);
---------

{% include sample.asciidoc lang="en" id="Easing" %}

You can see that the movement has changed from the ``quintOut``.


==== lerp

``lerp`` is a function of linear interpolation, which is included in `` tweenxcore.Tools.FloatTools``.

In the example above, it converts values in the specified range from 0.0 to 1.0 to values from 0 to 450. This will cause `` square.x`` to move from 0 to 450 while `` rate`` changes from 0.0 to 1.0.


== Principle of {{page.tweenxcore}}

=== Starting from 0.0 and ending with 1.0

In the {{page.tweenxcore}} world, the starting value is 0.0 and the ending value is 1.0.

That is,

* For time of motion, start time is expressed as 0.0 and end time is used as 1.0.
* For alpha, the complete transparency is 0.0 and the complete opacity is 1.0.
* For circle 1 turn, 0 degree is 0.0 and 360 degree is 1.0.
* For red values of RGB color, 0.0 is no redness and 1.0 is completely red.

In {{page.tweenxcore}}, we often use the variable name ``rate`` for such values that are based on 0.0 to 1.0.

=== No black box

{{page.tweenxcore}} does not have such a function as to automatically move objects by designating a departure point or a reaching point.

The function that the tween library automatically moves the object is easy if you just play the motion, but it will be difficult when you try to do somewhat elaborate things.

For example, it is as follows

* You want to **pause the animation** in the game when the pause button is pressed and **display the popup with animation**.
* You want to **switch to fade out immediately** after communication is finished **while the indicator is fading in**
* For some motion, You want to **play slow motion** only while mouse is down

With many tween libraries, you can not realize these behaviors or you have to remember complicated specifications.

In contrast, the solution for {{page.tweenxcore}} is straightforward.

* If you want to stop motion, **stop updating the place** you want to stop.
* Fade in and fade out can be **switched with a simple ``if`` statement**.
* If you **increment the `` frameCount`` by 0.5**, the playback speed of motion will be 0.5 times.

Nothing is difficult.

{{page.tweenxcore}} offers three things:
    
* Function to convert values not in the range of 0.0 to 1.0 from 0.0 to 1.0. (e.g. `` FloatTools.inverseLerp`` function, `` FloatChange`` class)
* Function to convert a number between 0.0 and 1.0 to a number between 0.0 and 1.0 with another curve. (e.g. `` Easing`` and custom easing functions)
* Function to convert a number between 0.0 and 1.0 to various values. (e.g. `` FloatTools.lerp`` and `` Timeline`` class)

If tween library has only these functions, you can freely create your own motions. The method will be explained in the tutorial.


=== Can be used anywhere

{{page.tweenxcore}} can be used without being interfering with the platform, the framework used together, and the programming paradigm.

* The style that you are aiming is well matched with {{page.tweenxcore}} whether it is object oriented, procedural programming, or functional programming.
* Whether the framework you use is OpenFL, React or Unity, it will work the same way.
* It works on client side, server side, even at compile time.


== {{page.tweenxcore}} Tutorial

=== Create your own easing
There are 44 kinds of easing in TweenXCore, but using these simply tends to be mediocre motion. In TweenXCore you can combine and mix easing to create your own easing.

==== 多重のイージング（関数合成）

イージングを2重、3重に使うと、新しい動きを作ることができます。

{% include sample.asciidoc lang="en" id="Composite" %}

```haxe
square.x = rate.cubicIn().bounceOut().lerp(0, 450);
```

``cubicIn``を使ってから``bounceOut``を使ってことで、加速していくバウンドのイージングを作っています。


==== ミックス

``mixEasing``は2つのイージングの中間的なイージングです。

{% include sample.asciidoc lang="en" id="Mix" %}

```haxe
square.x = rate.mixEasing(Easing.expoOutIn, Easing.linear, 0.18).lerp(0, 450);
```

サンプルはゲームのカットイン演出にありそうな動きです。``expoOutIn``に``linear``関数を``0.18``ミックスすることで、``OutIn``のイージングの真ん中での静止を無くしています。


==== クロスフェード

``crossfadeEasing``は、始まりと終わりで別のイージングに徐々に変わっていくようなイージングです。

{% include sample.asciidoc lang="en" id="Crossfade" %}

```haxe
square.x = rate.crossfadeEasing(
    Easing.quintOut,
    Easing.bounceOut,
    Easing.sineInOut
).lerp(0, 450);
```

サンプルは``quintOut``として始まって、徐々に``Easing.bounceOut``に変わっていくイージングです。変化の仕方の曲線として``Easing.sineInOut``を使っています。


==== ヨーヨー

ヨーヨーは0.0から1.0に行って、逆再生の動きで0.0に帰ってくるようなモーションです。

{% include sample.asciidoc lang="en" id="Yoyo" %}

```haxe
// ヨーヨー
square.x = rate.yoyo(Easing.quintOut).lerp(0, 450);
```

==== ジグザグ

ジグザグは0.0から1.0に行って、移動方向を反転させた動きで0.0に帰ってくるようなモーションです。

{% include sample.asciidoc lang="en" id="Zigzag" %}

```
// ジグザグ
square.x = rate.zigzag(Easing.quintOut).lerp(0, 450);
```


==== コネクト

``connectEasing``は、2つのイージングをつなげて再生する機能です。

{% include sample.asciidoc lang="en" id="Connect" %}

```haxe
square.x = rate.connectEasing(Easing.backOut, Easing.linear, 0.9, 0.4).lerp(0, 450);
```

サンプルでは、最初の``0.9``の時間で``0.4``の位置まで``backOut``で移動した後、残りを``linear``で移動しています。


==== ワンツー

``oneTwoEasing``は、別々のイージングで2回移動を行うイージングです。

{% include sample.asciidoc lang="en" id="OneTwo" %}

```haxe
square1.x = rate.oneTwoEasing(Easing.backIn, Easing.linear, 0.7).lerp(30, 420);
```

``backIn``で1回目の移動を、``linear``で2回目の移動を行っています。


==== CustomEasingクラス

このようなイージングのカスタム機能を何度も使う場合、自作のイージングをまとめたCustomEasingクラスを作っておくと便利です。

```haxe
using tweenxcore.Tools;

class CustomEasing {
    public static inline function quintQuintInOut(rate:Float) {
       return rate.quintInOut().quintInOut();
    }
}
```

このように``CustomEasing``クラスを定義しておけば、自分の作ったイージングを``using packageName.CustomEasing;``して簡単に利用できるようになります。


==== イージングエディタ

イージングエディタは、イージングを自作するためのツールです。イージングを組み合わせをブラウザ上で実際に試しながら作ることができます。

image::/images/easing_editor_ja.png[alt="イージングエディタ" class="large" link="./custom/"]
link:./custom/[イージングエディタ | TweenXCore]


=== 値の変化をあつかう（FloatChange）

これまでのサンプルは現在の値のみを使うものでしたが、直前の値と現在の値の両方を使うことで、さまざまな動作を作ることができます。

{{page.tweenxcore}}では、直前の値と現在の値をあつかう``FloatChange``というクラスを提供しています。

==== 値を横切った瞬間を取得

``FloatChange``を使用する例として、フレームカウントが特定の値を横切った瞬間の判定があります。

{% include sample.asciidoc lang="en" id="CrossOver" %}

```haxe
public function update():Void {
    var floatChange = new FloatChange(frameCount, frameCount += 1);
    
    // フレームカウントが30.0を横切った瞬間に、画面全体に四角を表示
    if (floatChange.isCrossOver(30.0)) {
        addChild(square = new Square());
        square.width = 481;
        square.height = 151;
    }
}
```

``new FloatChange``の第1引数は直前の値``previous``、第2引数は現在の値``current``で、``FloatChange``はこの2つの値をあつかうための便利関数を提供します。

``isCrossOver``関数は、この``previous``と``current``が指定した値を横切った瞬間のみ``true``になります。

この例の場合は``previous \<= 30.0 && 30.0 < current``または``current \<= 30.0 && 30.0 < previous``の条件で判定されます。

``FloatChange``は時間ベースでモーションをさせる場合に特に役に立ちます。例えば、``new FloatChange(previousTime, currentTime)``としたときに、**``previousTime``と``currentTime``がたまたま同一の値になったとしても、``isCrossOver``で判定した処理が2重に呼び出されることはありません。**

{sourceLink}tweenxcore/structure/FloatChange.hx[[ソースを見る(tweenxcore.structure.FloatChange)\]]


==== 値がある区間にいる間を取得

フレームが特定の区間にある時のモーションです。

{% include sample.asciidoc lang="en" id="FloatChangePart" %}

```haxe
public function update():Void {
    var floatChange = new FloatChange(frameCount, frameCount += 1);
    floatChange.handlePart(20.0, 50.5, updatePart);
}

private function updatePart(part:FloatChangePart):Void {
    var left  = part.previous.expoOutIn().lerp(0, 480);
    var right = part.current.expoOutIn().lerp(0, 480);
    
    square.x = left;
    square.width = right - left; 
}
```

``handlePart``関数は、``FloatChange``が指定した区間を移動しているときに、すぐに（同期処理で）第3引数であたえた関数を呼び出します。

この例では``20.0``から``50.5``の区間を通過しているときに、``updatePart``関数を呼び出します。

``updatePart``の第1引数の``FloatChangePart``は、開始値が``0.0``、終了値が``1.0``であるような``FloatChange``です。この場合、元の``FloatChange``値が``20.0``のとき``0.0``、``50.5``のとき``1.0``になるように対応させて渡されます。

この時、``FloatChangePart``の``current``と``previous``の値が``0.0``より低い値や、``1.0``より高い値で、``updatePart``が呼び出されることはありません。

{sourceLink}tweenxcore/structure/FloatChangePart.hx[[ソースを見る(tweenxcore.structure.FloatChangePart)\]]


==== 区間の開始と、終了を取得する

``FloatChangePart``には、モーションの開始タイミングや、終了タイミングを取得するための関数が用意されています。

{% include sample.asciidoc lang="en" id="EntranceExit" %}

```haxe
private function updatePart(part:FloatChangePart) {
    if (part.isEntrance()) {
        var topBar = new Square();
        addChild(topBar);
        topBar.width = 481;
    }

    square.x = part.current.expoIn().lerp(0, 450);

    if (part.isExit()) {
        var bottomBar = new Square();
        addChild(bottomBar);
        bottomBar.y = 120;
        bottomBar.width = 481;
    }
}
```

==== 繰り返し

1つのパートを、複数回繰り返したい場合、``handlePart``の代わりに``handleRepeatPart``を使います。

{% include sample.asciidoc lang="en" id="Repeat" %}

[source,haxe]
---------
change.handleRepeatPart(20, 40, 3, updatePart);
---------

このサンプルでは、20フレーム目から80フレーム目までの60フレームの間に``FloatChangePart``の0.0から1.0の移動が3回繰り返されています。

``handleRepeatPart``が``updateSquare``に引数として渡す``FloatChangePart``は``FloatChangeRepeatPart``として拡張したもので、現在が何回目の繰り返しかなどの追加の情報にアクセスができます。

{sourceLink}tweenxcore/structure/FloatChangeRepeatPart.hx[[ソースを見る(tweenxcore.structure.FloatChangeRepeatPart)\]]


====　連続したモーションをあつかう

連続したモーションをあつかうには、``FloatChange``の``handleTimelinePart``が使えます。

{% include sample.asciidoc lang="en" id="TimelinePart" %}

右、下、左の三つの移動を行いました。

```haxe
var timeline:Timeline<FloatChangeTimelinePart->Void>;

public function new() {
    // (中略)

    // 重み付きのupdate関数の配列を作成。
    timeline = new Timeline().add(update1, 1).add(update2, 2).add(update3, 5);
}

public function update():Void {
    var floatChange = new FloatChange(frameCount, frameCount += 1);

    floatChange.handleTimelinePart(0, 80, timeline);
}

private function update1(part:FloatChangeTimelinePart):Void {
    // 右へ移動
    square.x = part.current.lerp(0, 450);
}

private function update2(part:FloatChangeTimelinePart):Void {
    // 下へ移動
    square.y = part.current.cubicInOut().lerp(0, 120);
}

private function update3(part:FloatChangeTimelinePart):Void {
    // 左へ移動
    square.x = part.current.quartIn().cubicIn().lerp(450, 0);
}
```

``Timeline``は重み付きの配列です。配列の各要素に``Float``で重みがつけられています。サンプルでは``update1, update2, update3``に``1:2:5``の重みを付けています。

``handleTimelinePart``は、この重みに従ってupdate関数を呼び出します。サンプルでは、10フレームかけて``update1``を、20フレームかけて``update2``を、50フレームかけて``update3``を呼び出しています。

``FloatChangeTimelinePart``は``FloatChangePart``を継承しており、現在タイムラインのどの位置にいるかなどの情報が追加で取得できます。

{sourceLink}tweenxcore/structure/Timeline.hx[[ソースを見る(tweenxcore.structure.Timeline)\]]
{sourceLink}tweenxcore/structure/FloatChangeTimelinePart.hx[[ソースを見る(tweenxcore.structure.FloatChangeTimelinePart)\]]


=== 2次元の動き

==== 単純な動き
いままでのモーションはすべてX方向の動きをあつかってきましたが、Y方向の動きも入れてみます。

{% include sample.asciidoc lang="en" id="Xy" %}

```haxe
square.x = part.current.lerp(0, 450);
square.y = part.current.sinByRate().lerp(60, 105);
```

四角をY方向に揺らしてみました。ここで使っている``sinByRate``は円の一周を1.0としてあつかう``sin``関数です。

このサンプルはそれほど目新しくはありません。問題は同じようなモーションを斜め方向に行う場合です。

==== 相似変換
これまで0.0から1.0の値を実際の``x``座標に変換するのには``lerp``関数を使ってきましたが、回転が加わる場合``lerp``関数では表現できません。

そういった場合は、``MatrixTools.createSimilarityTransform``を使います。

{% include sample.asciidoc lang="en" id="Matrix" %}

```haxe
private var matrix:MatrixImpl;

public function new() {
    // (中略)

    // Flashプラットフォームなら、flash.geom.Matrixを使える。
    // pixi.jsや、OpenFLのなど場合、それぞれのフレームワークで定義されているMatrixが使える。
    // 実際のサンプルコードでは、自前でサンプル用に定義したクラスを使っている。
    matrix = new MatrixImpl();
    
    // (0, 0)から(1, 0)への移動を、(100, 0)から(350, 120)への移動に相似変換する行列を作成。
    matrix.createSimilarityTransform(100, 0, 350, 120);
}

private function updatePart(part:FloatChangePart):Void {
    var x = part.current;
    var y = part.current.sinByRate().lerp(0, 0.1);

    square.x = matrix.a * x + matrix.c * y + matrix.tx;
    square.y = matrix.b * x + matrix.d * y + matrix.ty;
}
```

``createSimilarityTransform(fromX, fromY, toX, toY)``関数は、X方向の0.0から1.0までの移動を、X方向に``fromX``から``toX``Y方向に``fromY``から``toY``の移動に相似変換するような行列を作成します。

==== 極座標

{{page.tweenxcore}}は極座標をサポートしています。

{% include sample.asciidoc lang="en" id="Polar" %}

```haxe
public function new() {
    // (中略)

    // 相似変換を作成
    matrix = new MatrixImpl();
    matrix.createSimilarityTransform(210, 60, 0, 0);
}

private function updatePart(part:FloatChangePart) {
    // 原点に近づいていく
    var distance = part.current.expoOut().lerp(1, 0);
    // 反時計回りに2周する。
    var angle = part.current.lerp(0, -2);
    
    // 極座標からXY座標へ変換
    var polarPoint = new PolarPoint(distance, angle);
    var x = polarPoint.x;
    var y = polarPoint.y;

    // 実際の座標へ変換
    square.x = matrix.a * x + matrix.c * y + matrix.tx;
    square.y = matrix.b * x + matrix.d * y + matrix.ty;
}
```

サンプルは、``(210, 60)``を極座標の中心として、そこに``(0, 0)``の位置から回転しながら近づいていくモーションです。

{sourceLink}tweenxcore/geom/PolarPoint.hx[[ソースを見る(tweenxcore.geom.PolarPoint)\]]


==== ベジェ曲線

{{page.tweenxcore}}はベジェ曲線もサポートしています。

{% include sample.asciidoc lang="en" id="Bezier" %}

```haxe
square.x = rate.bezier3(0, 50, 400, 450);
square.y = rate.bezier3(0, 200, -50, 120);
```

サンプルは、始点が``(0, 0)``、制御点が``(50, 200)``と``(400, -50)``、終点が``(450, 120)``の3次ベジェ曲線です。

ベジェ曲線は3次だけでなく任意の次数ののベジェ曲線が使えます。詳しくは``tweenxcore.Tools``モジュールを確認してください。

{sourceLink}tweenxcore/Tools.hx[[ソースを見る(tweenxcore.Tools)\]]



=== いろんなものを動かす

==== RGBカラー、HSVカラー

{{page.tweenxcore}}では、RGBカラーとHSVカラーが使えます。

{% include sample.asciidoc lang="en" id="Hsv" %}

```haxe
var curve = part.current.expoInOut();
var hue = hsvCurve.lerp(0.0, 1.0);        // 色相を1周させる
var saturation = hsvCurve.lerp(0.0, 0.8); // 彩度を上げていく
var value = 0.95;                         // 明度は固定 
var color = new HsvColor(hue, saturation, value);
```

サンプルはHSVのそれぞれの値を動かしながら帯を描いています。

{sourceLink}tweenxcore/color[[ソースを見る(tweenxcore.color)\]]



==== 画像

連続したモーションをあつかうのに重み付き配列の``Timeline``を紹介しましたが、この``Timeline``は連続でない値を動かすのにも使えます。

つまり、例えば画像のパラパラアニメーションを作るのにも使えます。

{% include sample.asciidoc lang="en" id="Image"%}



=== 時間以外に基づくトゥイーン

==== マウス座標を元にトゥイーンさせる

0.0から1.0の値に変換可能であればトゥイーンのもとになる値は、時間でなくても構いません。以下のサンプルでは、マウス座標を元に四角の位置を動かしています。

{% include sample.asciidoc lang="en" id="Mouse"%}

```haxe
var rateX = mouseX.inverseLerp(10, 800).clamp(0, 1);
var rateY = mouseY.repeat(0, 400);

square.x = rateX.expoInOut().lerp(0, 450);
square.y = rateY.yoyo(Easing.expoInOut).lerp(0, 120);
```

``inverseLerp``は、``lerp``とは逆向きの線形補間で、例では10から800までの値を0から1に変換しています。

``clamp``は下限と上限を設定する関数で、例では0より小さい値を0に、1より大きい値を1に変換しています。

``repeat``は繰り返しを行う関数で、まず0から400の値を0から1に変換するところまでは``inverseLerp``と同じですが、0より小さい値や400より大きい値など、指定した間隔の外側での挙動が違います。
つまり、``repeat``では-400から0、0から400、400から800、800から1200といった各値で0から1への変換がされます。



++++
<script src="/js/Sample.js"></script>
++++
